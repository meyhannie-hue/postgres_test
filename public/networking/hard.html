<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Networking Hard Level - Mixed T568B & Crossover</title>
  <!-- Enhanced viewport meta tag for better mobile responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    body { 
      margin: 0; 
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #0a1929, #001e3c, #0a1929);
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
      padding-top: 70px;
      color: #00ffff;
    }
    
    /* Circuit Board Background */
    .circuit-board {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.05;
      pointer-events: none;
      background-image: 
        linear-gradient(rgba(0, 229, 255, 0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 229, 255, 0.1) 1px, transparent 1px);
      background-size: 20px 20px;
    }
    
    /* Animated Circuit Traces */
    .circuit-traces {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.2;
      pointer-events: none;
    }
    
    .circuit-trace {
      position: absolute;
      background: linear-gradient(90deg, transparent, #00d4ff, transparent);
      height: 2px;
      animation: traceFlow 8s linear infinite;
    }
    
    @keyframes traceFlow {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    
    /* Digital Rain Background */
    .digital-rain {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.05;
      pointer-events: none;
    }
    
    /* Floating Particles */
    .particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
    }
    
    .particle {
      position: absolute;
      background: #00e5ff;
      border-radius: 50%;
      opacity: 0.3;
      animation: float 15s infinite linear;
    }
    
    @keyframes float {
      0% {
        transform: translateY(100vh) translateX(0);
        opacity: 0;
      }
      10% {
        opacity: 0.3;
      }
      90% {
        opacity: 0.3;
      }
      100% {
        transform: translateY(-100vh) translateX(100px);
        opacity: 0;
      }
    }
    
    /* Header Styles */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: rgba(74, 44, 80, 0.8);
      color: #fff;
      padding: 15px 20px;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 1000;
      box-shadow: 0 4px 15px rgba(0, 86, 179, 0.5);
    }
    
    .header-title {
      font-size: 20px;
      flex-grow: 1;
      text-align: center;
      font-weight: bold;
      color: #00ffff;
      text-shadow: 0 0 10px rgba(0, 229, 255, 0.7);
      animation: glow 2s infinite alternate;
      position: relative;
    }
    
    .header-title::before, .header-title::after {
      content: "Networking Hard Level - Mixed T568B & Crossover";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .header-title::before {
      animation: glitch-1 0.5s infinite;
      color: #00e5ff;
      z-index: -1;
    }
    
    .header-title::after {
      animation: glitch-2 0.5s infinite;
      color: #0078d4;
      z-index: -2;
    }
    
    @keyframes glow {
      from { text-shadow: 0 0 5px rgba(0, 229, 255, 0.7); }
      to { text-shadow: 0 0 15px rgba(0, 229, 255, 0.9); }
    }
    
    @keyframes glitch {
      0%, 100% { text-shadow: 0 0 10px rgba(0, 229, 255, 0.7); }
      20% { text-shadow: -2px 0 #00e5ff, 2px 0 #0078d4; }
      40% { text-shadow: 2px 0 #00e5ff, -2px 0 #0078d4; }
      60% { text-shadow: 0 0 10px rgba(0, 229, 255, 0.7); }
      80% { text-shadow: 2px 0 #00e5ff, -2px 0 #0078d4; }
    }
    
    @keyframes glitch-1 {
      0%, 100% { clip-path: inset(0 0 0 0); transform: translate(0); }
      20% { clip-path: inset(20% 0 30% 0); transform: translate(-2px); }
      40% { clip-path: inset(50% 0 20% 0); transform: translate(2px); }
      60% { clip-path: inset(10% 0 60% 0); transform: translate(0); }
      80% { clip-path: inset(80% 0 5% 0); transform: translate(-2px); }
    }
    
    @keyframes glitch-2 {
      0%, 100% { clip-path: inset(0 0 0 0); transform: translate(0); }
      20% { clip-path: inset(60% 0 10% 0); transform: translate(2px); }
      40% { clip-path: inset(20% 0 50% 0); transform: translate(-2px); }
      60% { clip-path: inset(30% 0 40% 0); transform: translate(0); }
      80% { clip-path: inset(5% 0 80% 0); transform: translate(2px); }
    }
    
    .back-button { 
      cursor: pointer; 
      font-size: 20px; 
      color: #ff00ff;
      transition: transform 0.2s ease, color 0.3s ease;
    }
    
    .back-button:hover { 
      transform: scale(1.2) rotate(-30deg); 
      color: #ff5eff;
    }
    
    .placeholder { width: 30px; }
    
    .instructions { 
      max-width: 800px;
      background: rgba(0, 30, 60, 0.7); 
      border: 1px solid #0056b3; 
      border-radius: 4px; 
      padding: 15px 20px; 
      margin: 10px 20px; 
      font-size: 14px; 
      line-height: 1.5; 
      color: #e0f7fa; 
      animation: fadeIn 1.2s ease-in-out;
      box-shadow: 0 0 15px rgba(0, 86, 179, 0.2);
      position: relative;
      overflow: hidden;
    }
    
    .instructions::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, transparent, #00e5ff, transparent);
      animation: scan-line 3s linear infinite;
    }
    
    .instructions strong { color: #00e5ff; }
    
    .tutorial-box { 
      margin: 15px auto; 
      padding: 12px 15px; 
      border: 1px solid #0056b3; 
      border-radius: 4px; 
      background: rgba(0, 20, 40, 0.8); 
      box-shadow: 0 0 10px rgba(0, 86, 179, 0.3); 
      text-align: center; 
      max-width: 500px; 
      min-height: 80px;
      position: relative;
      overflow: hidden;
    }
    
    .tutorial-box::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        90deg,
        transparent,
        transparent 2px,
        rgba(0, 229, 255, 0.05) 2px,
        rgba(0, 229, 255, 0.05) 4px
      );
      z-index: -1;
    }
    
    .tutorial-step { 
      font-size: 14px; 
      color: #e0f7fa; 
      opacity: 0; 
      transform: translateY(10px); 
      transition: opacity 0.6s ease, transform 0.6s ease; 
      position: relative;
    }
    
    .tutorial-step.active { 
      opacity: 1; 
      transform: translateY(0); 
      color: #00e5ff; 
      animation: typing 1.5s steps(20, end);
    }
    
    .video-caption { 
      font-size: 13px; 
      margin-top: 8px; 
      color: #90caf9; 
      font-style: italic; 
    }
    
    .start-btn { 
      margin-top: 20px; 
      padding: 10px 18px; 
      font-size: 16px; 
      font-weight: bold; 
      background: linear-gradient(45deg, #9527ae, #00ffff);
      color: #ffffff; 
      border: none; 
      border-radius: 8px; 
      cursor: pointer; 
      transition: 0.2s;
      font-family: 'Poppins', sans-serif;
      box-shadow: 0 0 8px rgba(0, 86, 179, 0.5);
      position: relative;
      overflow: hidden;
    }
    
    .start-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }
    
    .start-btn:hover::before {
      left: 100%;
    }
    
    .start-btn:hover { 
      background: linear-gradient(45deg, #219150, #ff00ff); 
      color: #ffffff; 
      box-shadow: 0 0 12px rgba(0, 229, 255, 0.7); 
    }
    
    .game-section { 
      display: none; 
      flex-direction: column; 
      align-items: center; 
      width: 100%; 
      opacity: 0; 
      animation: fadeIn 1s ease forwards; 
    }
    
    .timer { 
      font-size: 16px; 
      margin-bottom: 12px; 
      color: #00e5ff; 
      animation: pulse 2s infinite;
      text-shadow: 0 0 5px rgba(0, 229, 255, 0.7);
      font-family: 'Poppins', sans-serif;
    }
    
    .game { 
      display: flex; 
      position: relative; 
      justify-content: center; 
      width: 95%; 
      max-width: 1000px; 
      height: 600px; 
      margin: 0 auto;
    }
    
    #lineCanvas { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%;
      height: 100%;
      z-index: 2; 
      pointer-events: none; 
    }
    
    .column { 
      display: flex; 
      flex-direction: column; 
      gap: 18px; 
      padding: 10px; 
      z-index: 1; 
      justify-content: space-around;
    }
    
    #pinColumn { 
      margin-right: auto; 
      align-items: flex-end; 
    }
    
    #wireColumn { 
      margin-left: auto; 
      align-items: flex-start; 
    }
    
    .slot, .wire {
      position: relative;
      padding: 10px 15px; 
      border-radius: 6px; 
      font-size: 14px; 
      font-weight: bold;
      cursor: grab;
      user-select: none;
      width: 90px; 
      text-align: center;
      transition: transform 0.2s ease, box-shadow 0.3s ease;
      font-family: 'Poppins', sans-serif;
    }
    
    .slot { 
      background: rgba(0, 30, 60, 0.7); 
      border: 1px dashed #0056b3; 
      color: #e0f7fa; 
    }
    
    .slot.active {
      border: 1px solid #39ff14;
      box-shadow: 0 0 15px rgba(57, 255, 20, 0.7);
      animation: portGlow 1.5s infinite alternate;
    }
    
    @keyframes portGlow {
      from { box-shadow: 0 0 15px rgba(57, 255, 20, 0.7); }
      to { box-shadow: 0 0 25px rgba(0, 229, 255, 0.7); }
    }
    
    .slot.hover { 
      box-shadow: 0 0 10px rgba(0, 229, 255, 0.5); 
      transform: scale(1.05); 
    }
    
    .wire { 
      color: #0a1929; 
      border: 1px solid #0056b3; 
      background: #e0f7fa; 
      transition: transform 0.2s ease; 
    }
    
    .wire:active { 
      transform: scale(1.1); 
    }
    
    .wire.correct { 
      animation: glow 1s infinite alternate, pulse-success 1.5s infinite; 
    }
    
    .wire.incorrect { 
      animation: shake 0.4s, error-flash 0.5s; 
    }
    
    /* New style for placed wires */
    .wire.placed {
      opacity: 0.6;
      cursor: default;
      pointer-events: none;
      box-shadow: 0 0 8px rgba(57, 255, 20, 0.5);
    }
    
    .pin-dot { 
      position: absolute; 
      top: 50%; 
      transform: translateY(-50%); 
      width: 16px; 
      height: 16px; 
      border-radius: 50%; 
      background: #00e5ff;
      box-shadow: 0 0 5px rgba(0, 229, 255, 0.7);
    }
    
    .slot .pin-dot { 
      right: -12px; 
    }
    
    .wire .pin-dot { 
      left: -12px; 
    }
    
    .submit-btn {
      margin: 20px;
      padding: 12px 20px; 
      background: linear-gradient(45deg, #9527ae, #00ffff);
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      transition: 0.2s;
      font-size: 16px; 
      color: #ffffff;
      font-family: 'Poppins', sans-serif;
      box-shadow: 0 0 8px rgba(0, 86, 179, 0.5);
      position: relative;
      overflow: hidden;
    }
    
    .submit-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }
    
    .submit-btn:hover::before {
      left: 100%;
    }
    
    .submit-btn:hover { 
      background: linear-gradient(45deg, #219150, #ff00ff); 
      color: #ffffff; 
      box-shadow: 0 0 12px rgba(0, 229, 255, 0.7); 
    }
    
    #result { 
      font-size: 18px; 
      font-weight: bold; 
      margin: 8px; 
      text-align: center; 
      font-family: 'Poppins', sans-serif;
    }
    
    /* Data Packets */
    .data-packet {
      position: absolute;
      width: 10px; 
      height: 10px; 
      background: #39ff14;
      border-radius: 50%;
      box-shadow: 0 0 10px #39ff14;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
    }
    
    /* Animations */
    @keyframes fadeIn { 
      from { opacity: 0; transform: translateY(10px); } 
      to { opacity: 1; transform: translateY(0); } 
    }
    
    @keyframes pulse { 
      0% { text-shadow: 0 0 5px rgba(0, 229, 255, 0.7); } 
      50% { text-shadow: 0 0 15px rgba(0, 229, 255, 0.9); } 
      100% { text-shadow: 0 0 5px rgba(0, 229, 255, 0.7); } 
    }
    
    @keyframes shake { 
      0% { transform: translateX(0); } 
      25% { transform: translateX(-5px); } 
      50% { transform: translateX(5px); } 
      75% { transform: translateX(-5px); } 
      100% { transform: translateX(0); } 
    }
    
    @keyframes scan-line {
      0% { transform: translateY(-100%); }
      100% { transform: translateY(100%); }
    }
    
    @keyframes typing {
      from { width: 0; }
      to { width: 100%; }
    }
    
    @keyframes pulse-success {
      0% { box-shadow: 0 0 5px rgba(0, 229, 255, 0.7); }
      50% { box-shadow: 0 0 15px rgba(0, 229, 255, 0.9), 0 0 20px rgba(0, 229, 255, 0.5); }
      100% { box-shadow: 0 0 5px rgba(0, 229, 255, 0.7); }
    }
    
    @keyframes error-flash {
      0%, 100% { background-color: #e0f7fa; }
      25%, 75% { background-color: #ffcccc; }
      50% { background-color: #ff9999; }
    }
    
    @keyframes dataFlow {
      0% { opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      header {
        padding: 12px 15px;
      }
      
      .header-title {
        font-size: 16px;
      }
      
      .back-button {
        font-size: 18px;
      }
      
      .instructions {
        margin: 10px 15px;
        padding: 12px 15px;
        font-size: 13px;
      }
      
      .tutorial-box {
        margin: 10px auto;
        padding: 10px 12px;
        max-width: 90%;
      }
      
      .tutorial-step {
        font-size: 13px;
      }
      
      .start-btn {
        padding: 8px 15px;
        font-size: 14px;
      }
      
      .game {
        width: 95%;
        height: 550px; /* Increased from 450px */
      }
      
      .slot, .wire {
        width: 85px; /* Increased from 70px */
        font-size: 13px; /* Increased from 12px */
        padding: 10px 12px; /* Increased from 8px 10px */
      }
      
      .pin-dot {
        width: 16px; /* Increased from 14px */
        height: 16px; /* Increased from 14px */
      }
      
      .slot .pin-dot {
        right: -12px; /* Adjusted from -10px */
      }
      
      .wire .pin-dot {
        left: -12px; /* Adjusted from -10px */
      }
      
      .submit-btn {
        padding: 12px 18px; /* Increased from 10px 16px */
        font-size: 15px; /* Increased from 14px */
      }
    }
    
    /* Small mobile devices */
    @media (max-width: 480px) {
      /* Header adjustments */
      header {
        padding: 15px 10px;
      }
      
      .header-title {
        font-size: 18px; /* Increased for better readability */
      }
      
      .back-button {
        font-size: 24px; /* Larger back button for easier tapping */
      }
      
      /* Instructions section */
      .instructions {
        font-size: 15px; /* Larger text for better readability */
        padding: 15px; /* More padding for better spacing */
        margin: 10px 15px;
      }
      
      .instructions strong {
        font-size: 17px; /* Emphasized headings */
      }
      
      /* Tutorial box */
      .tutorial-box {
        padding: 15px; /* More padding */
        margin: 15px auto;
      }
      
      .tutorial-step {
        font-size: 15px; /* Larger tutorial text */
      }
      
      .video-caption {
        font-size: 14px; /* Increased caption size */
      }
      
      /* Buttons */
      .start-btn, .submit-btn {
        font-size: 18px; /* Larger button text */
        padding: 15px 25px; /* More padding for larger touch targets */
      }
      
      /* Game elements */
      .timer {
        font-size: 18px; /* Larger timer text */
      }
      
      .game {
        height: 480px; /* Adjusted height */
      }
      
      .slot, .wire {
        font-size: 14px; /* Larger text in game elements */
        padding: 12px 15px; /* More padding */
        width: 80px; /* Slightly wider for better text display */
      }
      
      #result {
        font-size: 20px; /* Larger result text */
      }
      
      /* Pin dots */
      .pin-dot {
        width: 18px; /* Larger pin dots */
        height: 18px;
      }
      
      .slot .pin-dot {
        right: -14px; /* Adjusted position */
      }
      
      .wire .pin-dot {
        left: -14px; /* Adjusted position */
      }
    }
    
    /* Extra small mobile devices */
    @media (max-width: 360px) {
      .game {
        height: 450px; /* Adjusted for very small screens */
      }
      
      .slot, .wire {
        width: 65px; /* Slightly smaller for very small screens */
        font-size: 11px;
        padding: 7px 8px;
      }
      
      .pin-dot {
        width: 12px;
        height: 12px;
      }
      
      .slot .pin-dot {
        right: -8px;
      }
      
      .wire .pin-dot {
        left: -8px;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
</head>
<body>
  <!-- Digital Rain Background -->
  <canvas class="digital-rain" id="digitalRain"></canvas>
  
  <!-- Circuit Board Pattern -->
  <div class="circuit-board"></div>
  
  <!-- Circuit Traces -->
  <div class="circuit-traces" id="circuitTraces"></div>
  
  <!-- Floating Particles -->
  <div class="particles" id="particles"></div>
  
  <!-- Header with Back Button -->
  <header>
    <div class="back-button" onclick="window.location.href='../levels/networkinglevels.html'">⤺</div>
    <div class="header-title">Networking Hard Level - Mixed T568B & Crossover</div>
    <div class="placeholder"></div>
  </header>
  
  <!-- Instructions -->
  <div class="instructions" id="instructions">
    <p><strong>Instructions:</strong></p>
    <ul>
      <li>Drag each <strong>wire</strong> from the right column and drop it onto the correct <strong>pin</strong> (1–8).</li>
      <li>Phase 1: T568B standard.</li>
      <li>Phase 2: Crossover standard.</li>
      <li>You have <strong>1 minute</strong> to complete both phases.</li>
      <li>Click <strong>Submit</strong> after each phase.</li>
    </ul>
    <div class="tutorial-box" id="tutorialBox">
      <div class="tutorial-step active">👋 Welcome! Hard level begins.</div>
      <div class="tutorial-step">➡ Phase 1: Arrange T568B wires.</div>
      <div class="tutorial-step">➡ Phase 2: Then arrange Crossover wires.</div>
      <div class="tutorial-step">▶ Click "Start Game" when ready!</div>
    </div>
    <p class="video-caption">📘 Steps auto-play below instead of video</p>
    <button class="start-btn" onclick="startGame()">▶ Start Game</button>
  </div>
  
  <!-- Game Section -->
  <div class="game-section" id="gameSection">
    <div class="timer">⏳ Time left: <span id="countdown">1:00</span></div>
    <div class="game">
      <canvas id="lineCanvas"></canvas>
      <div class="column" id="pinColumn"></div>
      <div class="column" id="wireColumn"></div>
    </div>
    <button class="submit-btn" onclick="checkWiring()">Submit Phase</button>
    <div id="result"></div>
  </div>
  
  <script>
    // Create floating particles
    const particlesContainer = document.getElementById('particles');
    const particleCount = 30;
    
    for (let i = 0; i < particleCount; i++) {
      const particle = document.createElement('div');
      particle.className = 'particle';
      
      // Random size between 2px and 6px
      const size = Math.random() * 4 + 2;
      particle.style.width = `${size}px`;
      particle.style.height = `${size}px`;
      
      // Random position
      particle.style.left = `${Math.random() * 100}%`;
      particle.style.top = `${Math.random() * 100}%`;
      
      // Random animation delay
      particle.style.animationDelay = `${Math.random() * 15}s`;
      
      particlesContainer.appendChild(particle);
    }
    
    // Create circuit traces
    const circuitTraces = document.getElementById('circuitTraces');
    const traceCount = 15;
    
    for (let i = 0; i < traceCount; i++) {
      const trace = document.createElement('div');
      trace.className = 'circuit-trace';
      trace.style.top = `${Math.random() * 100}%`;
      trace.style.width = `${Math.random() * 30 + 10}%`;
      trace.style.animationDelay = `${Math.random() * 8}s`;
      trace.style.animationDuration = `${Math.random() * 5 + 5}s`;
      circuitTraces.appendChild(trace);
    }
    
    // Digital Rain Effect (Purely Visual)
    const rainCanvas = document.getElementById('digitalRain');
    const rainCtx = rainCanvas.getContext('2d');
    
    // Function to set canvas size
    function setCanvasSize() {
      rainCanvas.width = window.innerWidth;
      rainCanvas.height = window.innerHeight;
    }
    
    // Set initial canvas size
    setCanvasSize();
    
    // Characters for the digital rain
    const characters = '01';
    const fontSize = 14;
    let columns = rainCanvas.width / fontSize;
    const drops = [];
    
    // Initialize drops
    for (let i = 0; i < columns; i++) {
      drops[i] = Math.random() * rainCanvas.height;
    }
    
    // Draw the digital rain
    function drawRain() {
      rainCtx.fillStyle = 'rgba(10, 25, 41, 0.05)';
      rainCtx.fillRect(0, 0, rainCanvas.width, rainCanvas.height);
      
      rainCtx.fillStyle = '#00e5ff';
      rainCtx.font = `${fontSize}px monospace`;
      
      for (let i = 0; i < drops.length; i++) {
        const text = characters.charAt(Math.floor(Math.random() * characters.length));
        rainCtx.fillText(text, i * fontSize, drops[i] * fontSize);
        
        if (drops[i] * fontSize > rainCanvas.height && Math.random() > 0.975) {
          drops[i] = 0;
        }
        
        drops[i]++;
      }
    }
    
    // Animation loop for digital rain
    setInterval(drawRain, 33);
    
    // Resize canvas when window is resized
    window.addEventListener('resize', () => {
      setCanvasSize();
      // Recalculate columns after resize
      columns = rainCanvas.width / fontSize;
      // Reinitialize drops array for new canvas size
      drops.length = 0;
      for (let i = 0; i < columns; i++) {
        drops[i] = Math.random() * rainCanvas.height;
      }
    });
    
    // === Tutorial ===
    const steps = document.querySelectorAll(".tutorial-step");
    let stepIndex = 0;
    setInterval(() => {
      steps.forEach((s, i) => s.classList.toggle("active", i === stepIndex));
      stepIndex = (stepIndex + 1) % steps.length;
    }, 3000);
    
    // === Game Variables (Original Backend Logic) ===
    const canvas = document.getElementById('lineCanvas');
    const ctx = canvas.getContext('2d');
    let phase = 1; // 1 = T568B, 2 = Crossover
    let connections = [];
    let startWire = null;
    let timeLeft = 60; // 1 minute
    let timerStarted = false;
    let timer;
    const countdownEl = document.getElementById('countdown');
    const resultEl = document.getElementById('result');
    const phases = {
      1: ['White-Orange','Orange','White-Green','Blue','White-Blue','Green','White-Brown','Brown'], // T568B
      2: ['White-Green','Green','White-Orange','Blue','White-Blue','Orange','White-Brown','Brown']   // Crossover
    };
    
    // Animation variables for data flow
    let animationProgress = 0;
    let animationId = null;
    
    // Function to set game canvas size
    function setGameCanvasSize() {
      const gameContainer = document.querySelector('.game');
      canvas.width = gameContainer.offsetWidth;
      canvas.height = gameContainer.offsetHeight;
    }
    
    function startGame() {
      document.getElementById("instructions").style.display = "none";
      const section = document.getElementById("gameSection");
      section.style.display = "flex";
      section.style.animation = "fadeIn 1s ease forwards";
      
      // Set canvas size when starting the game
      setGameCanvasSize();
      
      startTimer();
      buildPins();
      buildWires();
      startAnimation();
      // 🎵 Start background music
      startGameMusic();
    }
    
    function startTimer() {
      if (timerStarted) return;
      timerStarted = true;
      countdownEl.textContent = formatTime(timeLeft);
      timer = setInterval(() => {
        timeLeft--;
        countdownEl.textContent = formatTime(timeLeft);
        if(timeLeft <= 0){
          clearInterval(timer);
          alert("⏰ Time's up! Game over.");
          location.reload();
        }
      },1000);
    }
    
    function formatTime(seconds){
      const m = Math.floor(seconds/60);
      const s = seconds % 60;
      return `${m}:${s<10?'0':''}${s}`;
    }
    
    function buildPins(){
      const pins = document.getElementById('pinColumn');
      pins.innerHTML = '';
      for(let i=1;i<=8;i++){
        const slot = document.createElement('div');
        slot.className = 'slot';
        slot.dataset.pin = i;
        slot.innerHTML = `Pin ${i} <span class="pin-dot"></span>`;
        pins.appendChild(slot);
        slot.addEventListener('dragover', e => { 
          e.preventDefault(); 
          slot.classList.add('hover'); 
        });
        slot.addEventListener('dragleave', () => { 
          slot.classList.remove('hover'); 
        });
        slot.addEventListener('drop', (e) => {
          e.preventDefault();
          slot.classList.remove('hover');
          
          // Check if wire is already placed
          if (startWire.classList.contains('placed')) {
            return;
          }
          
          const pin = slot.getAttribute('data-pin');
          const color = startWire.getAttribute('data-color');
          
          // Check if this pin already has a wire
          const existingConnection = connections.find(c => c.pin === pin);
          if (existingConnection) {
            // Remove the existing connection and make the wire available again
            existingConnection.wire.classList.remove('placed');
            existingConnection.wire.draggable = true;
            existingConnection.wire.style.cursor = 'grab';
            // Remove active class from the slot
            document.querySelector(`.slot[data-pin="${pin}"]`).classList.remove('active');
          }
          
          // Check if this wire is already connected to another pin
          const wireConnection = connections.find(c => c.color === color);
          if (wireConnection) {
            // Remove the connection and make the wire available again
            wireConnection.wire.classList.remove('placed');
            wireConnection.wire.draggable = true;
            wireConnection.wire.style.cursor = 'grab';
            // Remove active class from the previous slot
            document.querySelector(`.slot[data-pin="${wireConnection.pin}"]`).classList.remove('active');
          }
          
          // Filter out the old connections for this pin and wire
          connections = connections.filter(c => c.pin !== pin && c.color !== color);
          
          // Add the new connection
          connections.push({pin,color,wire:startWire});
          
          // Mark the wire as placed
          startWire.classList.add('placed');
          startWire.draggable = false;
          startWire.style.cursor = 'default';
          
          // Add active class to the slot
          slot.classList.add('active');
          
          drawConnections();
          
          // Create data packet animation for correct connections
          if (isCorrectConnection(pin, color)) {
            createDataPacket(pin, color);
          }
        });
      }
    }
    
    // Check if connection is correct for current phase
    function isCorrectConnection(pin, color) {
      const correctOrder = phases[phase];
      return correctOrder[parseInt(pin) - 1] === color;
    }
    
    // Create animated data packet
    function createDataPacket(pin, color) {
      const packet = document.createElement('div');
      packet.className = 'data-packet';
      document.body.appendChild(packet);
      
      const slot = document.querySelector(`.slot[data-pin="${pin}"]`);
      const wire = connections.find(c => c.pin === pin && c.color === color).wire;
      
      const slotRect = slot.getBoundingClientRect();
      const wireRect = wire.getBoundingClientRect();
      
      const startX = wireRect.left + wireRect.width / 2;
      const startY = wireRect.top + wireRect.height / 2;
      const endX = slotRect.left + slotRect.width / 2;
      const endY = slotRect.top + slotRect.height / 2;
      
      packet.style.left = `${startX}px`;
      packet.style.top = `${startY}px`;
      
      // Animate the packet along the connection
      packet.style.animation = 'dataFlow 2s ease-in-out';
      packet.style.opacity = '1';
      
      // Move the packet from start to end
      setTimeout(() => {
        packet.style.transition = 'all 1.5s cubic-bezier(0.42, 0, 0.58, 1)';
        packet.style.left = `${endX}px`;
        packet.style.top = `${endY}px`;
      }, 100);
      
      // Remove the packet after animation
      setTimeout(() => {
        packet.remove();
      }, 2000);
    }
    
    function buildWires(){
      const wiresData = {
        "White-Orange":"linear-gradient(to right, white 50%, orange 50%)",
        "Orange":"orange",
        "White-Green":"linear-gradient(to right, white 50%, green 50%)",
        "Blue":"blue",
        "White-Blue":"linear-gradient(to right, white 50%, blue 50%)",
        "Green":"green",
        "White-Brown":"linear-gradient(to right, white 50%, brown 50%)",
        "Brown":"brown"
      };
      const wireContainer = document.getElementById('wireColumn');
      wireContainer.innerHTML = '';
      let colors = Object.keys(wiresData).sort(() => 0.5 - Math.random());
      colors.forEach(color => {
        const div = document.createElement('div');
        div.className = 'wire';
        div.draggable = true;
        div.dataset.color = color;
        div.style.background = wiresData[color];
        div.innerHTML = `<span class="pin-dot"></span> ${color}`;
        wireContainer.appendChild(div);
        div.addEventListener('dragstart', (e) => { 
          // Prevent dragging if wire is already placed
          if (div.classList.contains('placed')) {
            e.preventDefault();
            return;
          }
          startWire = div; 
          startTimer(); 
          e.dataTransfer.effectAllowed = 'move';
        });
        div.addEventListener('mousedown', startTimer);
        div.addEventListener('touchstart', startTimer);
      });
    }
    
    // Draw connections with data flow animation (Enhanced but Preserves Original Logic)
    function drawConnections(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const rect = canvas.getBoundingClientRect();
      
      connections.forEach(conn=>{
        const pinDot = document.querySelector(`.slot[data-pin="${conn.pin}"] .pin-dot`).getBoundingClientRect();
        const wireDot = conn.wire.querySelector('.pin-dot').getBoundingClientRect();
        const x1 = wireDot.left + wireDot.width/2 - rect.left;
        const y1 = wireDot.top + wireDot.height/2 - rect.top;
        const x2 = pinDot.left + pinDot.width/2 - rect.left;
        const y2 = pinDot.top + pinDot.height/2 - rect.top;
        
        // Create flowing curves instead of straight lines
        const dx = x2 - x1;
        const dy = y2 - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Add natural sag based on wire length
        const sagAmount = Math.min(distance * 0.3, 80);
        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2 + sagAmount;
        
        // Add slight random variations for natural look
        const variation1X = (Math.random() - 0.5) * 20;
        const variation1Y = (Math.random() - 0.5) * 15;
        const variation2X = (Math.random() - 0.5) * 20;
        const variation2Y = (Math.random() - 0.5) * 15;
        
        const cp1X = x1 + dx * 0.3 + variation1X;
        const cp1Y = y1 + dy * 0.3 + sagAmount * 0.5 + variation1Y;
        const cp2X = x2 - dx * 0.3 + variation2X;
        const cp2Y = y2 - dy * 0.3 + sagAmount * 0.5 + variation2Y;
        
        // Draw the connection line
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, x2, y2);
        ctx.lineWidth = 5; // Increased from 4px
        ctx.lineCap = 'round';
        
        // Apply IT theme to connection lines
        if (conn.color.includes('-')) {
          const parts = conn.color.split('-');
          const c1 = parts[0].toLowerCase();
          const c2 = parts[1].toLowerCase();
          const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
          
          // IT-themed gradient
          if (c1 === 'white' && c2 === 'green') {
            gradient.addColorStop(0, '#00e5ff');
            gradient.addColorStop(1, '#0056b3');
          } else if (c1 === 'white' && c2 === 'orange') {
            gradient.addColorStop(0, '#00e5ff');
            gradient.addColorStop(1, '#0078d4');
          } else if (c1 === 'white' && c2 === 'blue') {
            gradient.addColorStop(0, '#00e5ff');
            gradient.addColorStop(1, '#0056b3');
          } else if (c1 === 'white' && c2 === 'brown') {
            gradient.addColorStop(0, '#0078d4');
            gradient.addColorStop(1, '#0056b3');
          } else {
            gradient.addColorStop(0, c1);
            gradient.addColorStop(1, c2);
          }
          
          ctx.strokeStyle = gradient;
        } else {
          // IT-themed solid colors
          switch(conn.color.toLowerCase()) {
            case 'green':
              ctx.strokeStyle = '#00e5ff';
              break;
            case 'blue':
              ctx.strokeStyle = '#0056b3';
              break;
            case 'orange':
              ctx.strokeStyle = '#0078d4';
              break;
            case 'brown':
              ctx.strokeStyle = '#004080';
              break;
            default:
              ctx.strokeStyle = conn.color.toLowerCase();
          }
        }
        
        // Add glow effect to lines
        ctx.shadowColor = '#00e5ff';
        ctx.shadowBlur = 8; // Increased from 5px
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Draw data flow animation (Purely Visual)
        if (connections.length > 0) {
          // Calculate position along the bezier curve
          const t = animationProgress;
          const t2 = t * t;
          const t3 = t2 * t;
          const mt = 1 - t;
          const mt2 = mt * mt;
          const mt3 = mt2 * mt;
          
          const flowX = mt3 * x1 + 3 * mt2 * t * cp1X + 3 * mt * t2 * cp2X + t3 * x2;
          const flowY = mt3 * y1 + 3 * mt2 * t * cp1Y + 3 * mt * t2 * cp2Y + t3 * y2;
          
          // Draw data packet
          ctx.beginPath();
          ctx.arc(flowX, flowY, 8, 0, Math.PI * 2); // Increased from 6px
          ctx.fillStyle = '#39ff14';
          ctx.fill();
          
          // Add glow to data packet
          ctx.beginPath();
          ctx.arc(flowX, flowY, 12, 0, Math.PI * 2); // Increased from 10px
          const gradient = ctx.createRadialGradient(flowX, flowY, 0, flowX, flowY, 12);
          gradient.addColorStop(0, 'rgba(57, 255, 20, 0.8)');
          gradient.addColorStop(1, 'rgba(57, 255, 20, 0)');
          ctx.fillStyle = gradient;
          ctx.fill();
        }
      });
    }
    
    // Start animation loop (Purely Visual)
    function startAnimation() {
      function animate() {
        animationProgress += 0.01;
        if (animationProgress > 1) animationProgress = 0;
        
        drawConnections();
        animationId = requestAnimationFrame(animate);
      }
      
      if (animationId) cancelAnimationFrame(animationId);
      animate();
    }
    
    function checkWiring() {
      const correctOrder = phases[phase];
      if (connections.length < 8) {
        alert("⚠️ Incomplete: Please connect all wires.");
        return;
      }
      const currentOrder = [];
      for (let i = 1; i <= 8; i++) {
        const match = connections.find(c => c.pin === i.toString());
        currentOrder.push(match ? match.color : null);
      }
      let correct = 0;
      connections.forEach(c => c.wire.classList.remove("correct", "incorrect"));
      correctOrder.forEach((c, i) => {
        if (c === currentOrder[i]) {
          correct++;
          const wireObj = connections.find(conn => conn.color === c);
          if (wireObj) wireObj.wire.classList.add("correct");
        } else {
          const wireObj = connections.find(conn => conn.color === currentOrder[i]);
          if (wireObj) wireObj.wire.classList.add("incorrect");
        }
      });
      if (correct === 8) {
        if (phase === 1) {
          alert("✅ Phase 1 complete! Now Phase 2: Crossover.");
          phase = 2;
          connections = [];
          buildPins();
          buildWires();
          resultEl.textContent = "";
        } else {
          resultEl.textContent = "🎉 Perfect! Hard Level Complete!";
          resultEl.style.color = "#00ff00";
          alert("🎉 Phase 2 complete! You mastered T568B + Crossover!");
          // === Reward API call after completing both phases ===
          const username = localStorage.getItem("loggedInUser");
          if (username) {
            fetch("https://postgres-test-p05s.onrender.com/api/reward", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                username,
                points: 6120, // Reward for full hard level
                coins: 4560,
                reason: "Perfect Score Hard Level"
              })
            })
            .then(res => res.json())
            .then(data => {
              if (data.success) {
                alert("🏆 You earned 6120 points and 4560 coins!");
                // ✅ Redirect after reward success
                window.location.href = "../levels/networkinglevels.html";
              } else {
                console.error("Reward API failed:", data);
                // Still redirect even if API fails
                window.location.href = "../levels/networkinglevels.html";
              }
            })
            .catch(err => {
              console.error("Reward error:", err);
              // Redirect even if error
              window.location.href = "../levels/networkinglevels.html";
            });
          } else {
            console.log("username is null");
            // Redirect even if no username
            window.location.href = "../levels/networkinglevels.html";
          }
        }
      } else {
        alert(`❌ Some wires are incorrect. Correct: ${correct}/8`);
      }
    }
    
    // Handle window resize for game canvas
    window.addEventListener('resize', () => {
      if (document.getElementById('gameSection').style.display === 'flex') {
        setGameCanvasSize();
        drawConnections();
      }
    });
    
    // === 🎵 GAME MUSIC SYSTEM ===
    let audioCtx, masterGain, intervalIds = [];
    function startGameMusic() {
      if (audioCtx) return; // already playing
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.8; // 🎚 overall volume
      masterGain.connect(audioCtx.destination);
      // 🔹 Driving Bassline
      intervalIds.push(setInterval(() => {
        playTone(55, "square", 0.3, 0.4); // Low note
        setTimeout(() => playTone(110, "square", 0.2, 0.3), 200); // Octave hit
      }, 800));
      // 🔹 Melody Arpeggio (classic retro blips)
      intervalIds.push(setInterval(() => {
        let notes = [440, 494, 523, 587, 659, 698, 784]; // C major scale
        let note = notes[Math.floor(Math.random() * notes.length)];
        playTone(note, "square", 0.25, 0.25);
      }, 300));
      // 🔹 Hi-Hat / Percussion
      intervalIds.push(setInterval(() => {
        playNoise(0.03, 0.2);
      }, 200));
      // 🔹 Kick Drum (boom effect)
      intervalIds.push(setInterval(() => {
        playKick();
      }, 1200));
    }
    function stopGameMusic() {
      intervalIds.forEach(id => clearInterval(id));
      intervalIds = [];
      if (audioCtx) {
        audioCtx.close();
        audioCtx = null;
      }
    }
    // === SOUND GENERATORS ===
    function playTone(freq, type, duration, volume) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      gain.gain.value = volume;
      osc.type = type;
      osc.frequency.value = freq;
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }
    function playNoise(duration, volume) {
      const bufferSize = audioCtx.sampleRate * duration;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1; // white noise
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      const gain = audioCtx.createGain();
      gain.gain.value = volume;
      noise.connect(gain);
      gain.connect(masterGain);
      noise.start();
      noise.stop(audioCtx.currentTime + duration);
    }
    function playKick() {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(150, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
      gain.gain.setValueAtTime(0.6, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.5);
    }
  </script>
</body>
</html>