<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cable Chaos: Network Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow-y: auto; /* Changed from hidden to auto */
            min-height: 100vh;
            position: relative;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh; /* Changed from height to min-height */
            padding: 10px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 15px;
            border-radius: 15px;
            margin-bottom: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            flex-wrap: wrap;
            position: sticky; /* Added to keep header visible when scrolling */
            top: 0;
            z-index: 100;
        }
        .game-title {
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff88, #00bbff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
            flex-grow: 1;
            text-align: center;
        }
        .stats {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 10px;
            min-width: 60px;
        }
        .stat-label {
            font-size: 10px;
            opacity: 0.8;
            text-transform: uppercase;
        }
        .stat-value {
            font-size: 16px;
            font-weight: bold;
        }
        .timer {
            color: #ff6b6b;
        }
        .timer.warning {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .main-game {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .devices-area {
            flex: 1;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            padding: 20px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            min-height: 300px;
        }
        .device {
            position: absolute;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: move;
            transition: all 0.3s ease;
            user-select: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .device:hover {
            transform: scale(1.05);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
        }
        .device.dragging {
            opacity: 0.8;
            z-index: 1000;
        }
        .device-icon {
            font-size: 32px;
            margin-bottom: 3px;
        }
        .device-name {
            font-size: 10px;
            text-align: center;
            font-weight: bold;
        }
        .port {
            position: absolute;
            width: 18px;
            height: 18px;
            background: #333;
            border: 2px solid #666;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 5;
        }
        .port:hover {
            background: #555;
            transform: scale(1.2);
        }
        .port.connected {
            background: #4caf50;
            border-color: #81c784;
        }
        .port.highlight {
            box-shadow: 0 0 15px #00ff88;
            animation: portGlow 1s infinite;
        }
        @keyframes portGlow {
            0%, 100% { box-shadow: 0 0 15px #00ff88; }
            50% { box-shadow: 0 0 25px #00ff88, 0 0 35px #00ff88; }
        }
        .cables-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            overflow-x: auto;
            white-space: nowrap;
            -webkit-overflow-scrolling: touch;
        }
        .cables-title {
            font-size: 16px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
        }
        .cable-item {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 10px;
            margin-right: 10px;
            cursor: grab;
            transition: all 0.3s ease;
            width: 140px;
            vertical-align: top;
        }
        .cable-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-3px);
        }
        .cable-item.dragging {
            cursor: grabbing;
            opacity: 0.5;
        }
        .cable-item.selected {
            background: rgba(255, 255, 255, 0.3);
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        .cable-color {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            flex-shrink: 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            margin: 0 auto 5px;
        }
        .ethernet { background: linear-gradient(45deg, #ff6b6b, #ff8787); }
        .fiber { background: linear-gradient(45deg, #4ecdc4, #44a3aa); }
        .crossover { background: linear-gradient(45deg, #ffe66d, #ffd93d); }
        .cable-info {
            text-align: center;
        }
        .cable-name {
            font-weight: bold;
            margin-bottom: 3px;
            font-size: 12px;
        }
        .cable-desc {
            font-size: 10px;
            opacity: 0.8;
        }
        .connection-line {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }
        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 2000;
            display: none;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 90%;
        }
        .message.show {
            display: block;
            animation: messageSlide 0.5s ease;
        }
        @keyframes messageSlide {
            from {
                transform: translate(-50%, -60%);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }
        .message h2 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        .message.success h2 { color: #4caf50; }
        .message.error h2 { color: #ff6b6b; }
        .message.warning h2 { color: #ff9800; }
        .btn {
            background: linear-gradient(45deg, #00ff88, #00bbff);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }
        .particle {
            position: absolute;
            pointer-events: none;
            width: 4px;
            height: 4px;
            background: #00ff88;
            border-radius: 50%;
            animation: particleFloat 1s ease-out forwards;
        }
        @keyframes particleFloat {
            to {
                transform: translateY(-100px);
                opacity: 0;
            }
        }
        .level-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .hint-btn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 15px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .hint-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        .hint-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .reset-btn {
            background: rgba(255, 107, 107, 0.3);
            border: 2px solid rgba(255, 107, 107, 0.5);
            color: white;
            padding: 8px 15px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            margin-top: 10px;
            font-size: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .reset-btn:hover {
            background: rgba(255, 107, 107, 0.5);
            transform: scale(1.05);
        }
        .instructions {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 10px;
            margin-top: 10px;
            font-size: 12px;
            line-height: 1.4;
            max-height: 150px; /* Set a fixed height */
            overflow-y: auto; /* Enable vertical scrolling */
            scrollbar-width: thin; /* For Firefox */
            scrollbar-color: #00ff88 rgba(0, 0, 0, 0.2); /* For Firefox */
        }
        
        /* Custom scrollbar for Webkit browsers */
        .instructions::-webkit-scrollbar {
            width: 8px;
        }
        
        .instructions::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        .instructions::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 4px;
        }
        
        .instructions::-webkit-scrollbar-thumb:hover {
            background: #00cc6a;
        }
        
        .instructions h3 {
            margin-bottom: 8px;
            color: #00ff88;
            font-size: 14px;
        }
        .instructions ol {
            padding-left: 15px;
        }
        .instructions li {
            margin-bottom: 3px;
        }
        .points-display, .coins-display {
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .points-icon, .coins-icon {
            font-size: 16px;
        }
        .points-icon { color: #ffe66d; }
        .coins-icon { color: #ffd700; }
        .points-value, .coins-value {
            font-size: 16px;
            font-weight: bold;
        }
        .points-value { color: #ffe66d; }
        .coins-value { color: #ffd700; }
        
        /* Back button styles */
        .back-button {
            font-size: 24px;
            cursor: pointer;
            color: #00ff88;
            transition: transform 0.3s ease, color 0.3s ease;
            margin-right: 15px;
        }
        
        .back-button:hover {
            transform: scale(1.2);
            color: #00cc6a;
        }
        
        /* Confirmation dialog styles */
        .confirm-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border-radius: 15px;
            padding: 20px;
            z-index: 3000;
            display: none;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 80%;
            text-align: center;
        }
        
        .confirm-dialog.show {
            display: block;
            animation: messageSlide 0.5s ease;
        }
        
        .confirm-dialog h3 {
            color: #ff9800;
            margin-bottom: 15px;
            font-size: 20px;
        }
        
        .confirm-dialog p {
            margin-bottom: 20px;
            font-size: 16px;
        }
        
        .confirm-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        .confirm-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        .confirm-yes {
            background: linear-gradient(45deg, #ff6b6b, #ff8787);
            color: white;
        }
        
        .confirm-yes:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
        }
        
        .confirm-no {
            background: linear-gradient(45deg, #00ff88, #00bbff);
            color: white;
        }
        
        .confirm-no:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }
        
        /* Mobile-specific adjustments */
        @media (max-width: 768px) {
            .game-container {
                padding: 5px;
            }
            .header {
                padding: 8px 10px;
                margin-bottom: 8px;
            }
            .game-title {
                font-size: 18px;
            }
            .stats {
                gap: 5px;
            }
            .stat-item {
                min-width: 50px;
                padding: 3px 8px;
            }
            .stat-value {
                font-size: 14px;
            }
            .stat-label {
                font-size: 9px;
            }
            .main-game {
                gap: 8px;
            }
            .devices-area {
                padding: 15px;
                min-height: 250px;
            }
            .device {
                width: 70px;
                height: 70px;
            }
            .device-icon {
                font-size: 28px;
            }
            .device-name {
                font-size: 9px;
            }
            .port {
                width: 16px;
                height: 16px;
            }
            .cables-panel {
                padding: 10px;
            }
            .cables-title {
                font-size: 14px;
                margin-bottom: 8px;
            }
            .cable-item {
                width: 120px;
                padding: 8px;
                margin-right: 8px;
            }
            .cable-color {
                width: 25px;
                height: 25px;
                margin-bottom: 3px;
            }
            .cable-name {
                font-size: 11px;
            }
            .cable-desc {
                font-size: 9px;
            }
            .message {
                padding: 15px 20px;
            }
            .message h2 {
                font-size: 20px;
            }
            .btn {
                padding: 8px 15px;
                font-size: 12px;
            }
            .level-indicator {
                padding: 4px 12px;
                font-size: 12px;
            }
            .hint-btn {
                padding: 6px 12px;
                font-size: 11px;
            }
            .reset-btn {
                padding: 6px 12px;
                font-size: 11px;
            }
            .instructions {
                font-size: 11px;
                padding: 8px;
                max-height: 120px; /* Adjusted for mobile */
            }
            .instructions h3 {
                font-size: 12px;
                margin-bottom: 5px;
            }
            .points-display, .coins-display {
                padding: 3px 8px;
            }
            .points-icon, .coins-icon {
                font-size: 14px;
            }
            .points-value, .coins-value {
                font-size: 14px;
            }
            .back-button {
                font-size: 20px;
                margin-right: 10px;
            }
            .confirm-dialog {
                padding: 15px;
                max-width: 90%;
            }
            .confirm-dialog h3 {
                font-size: 18px;
                margin-bottom: 10px;
            }
            .confirm-dialog p {
                font-size: 14px;
                margin-bottom: 15px;
            }
            .confirm-btn {
                padding: 8px 15px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <div class="back-button" onclick="showConfirmDialog()">‚§∫</div>
            <h1 class="game-title">Cable Chaos: Network Puzzle</h1>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Score</span>
                    <span class="stat-value" id="score">0</span>
                </div>
                <div class="points-display">
                    <span class="points-icon">‚≠ê</span>
                    <span class="points-value" id="points">0</span>
                </div>
                <div class="coins-display">
                    <span class="coins-icon">ü™ô</span>
                    <span class="coins-value" id="coins">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Time</span>
                    <span class="stat-value timer" id="timer">60</span>
                </div>
            </div>
        </div>
        <div class="main-game">
            <div class="devices-area" id="devicesArea">
                <div class="level-indicator">Level <span id="level">1</span></div>
                <button class="hint-btn" id="hintBtn" onclick="showHint()">üí° Hint (3)</button>
            </div>
            <div class="cables-panel">
                <h2 class="cables-title">Available Cables</h2>
                <div style="display: flex; overflow-x: auto; -webkit-overflow-scrolling: touch;">
                    <div class="cable-item" draggable="true" data-cable-type="ethernet">
                        <div class="cable-color ethernet"></div>
                        <div class="cable-info">
                            <div class="cable-name">Ethernet</div>
                            <div class="cable-desc">PC to Switch</div>
                        </div>
                    </div>
                    <div class="cable-item" draggable="true" data-cable-type="fiber">
                        <div class="cable-color fiber"></div>
                        <div class="cable-info">
                            <div class="cable-name">Fiber Optic</div>
                            <div class="cable-desc">Router to Router</div>
                        </div>
                    </div>
                    <div class="cable-item" draggable="true" data-cable-type="crossover">
                        <div class="cable-color crossover"></div>
                        <div class="cable-info">
                            <div class="cable-name">Crossover</div>
                            <div class="cable-desc">PC to PC</div>
                        </div>
                    </div>
                </div>
                <button class="reset-btn" onclick="resetLevel()">üîÑ Reset Level</button>
                <div class="instructions">
                    <h3>How to Play:</h3>
                    <ol>
                        <li>Tap a cable type to select</li>
                        <li>Tap a device port</li>
                        <li>Tap another port to connect</li>
                        <li>Complete before time runs out!</li>
                        <li>Connect devices using the correct cable types</li>
                        <li>Earn points for each correct connection</li>
                        <li>Use hints if you get stuck</li>
                        <li>Complete all levels to win the game</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>
    
    <div class="message" id="message">
        <h2 id="messageTitle"></h2>
        <p id="messageText"></p>
        <button class="btn" onclick="hideMessage()">Continue</button>
    </div>
    
    <!-- Confirmation Dialog -->
    <div class="confirm-dialog" id="confirmDialog">
        <h3>Quit Game?</h3>
        <p>Are you sure you want to quit? Your progress will be lost.</p>
        <div class="confirm-buttons">
            <button class="confirm-btn confirm-yes" onclick="quitGame()">Yes, Quit</button>
            <button class="confirm-btn confirm-no" onclick="hideConfirmDialog()">No, Continue</button>
        </div>
    </div>
    
    <script>
        // Game state
        let gameState = {
            score: 0,
            points: 0,
            coins: 0,
            connections: 0,
            timeLeft: 60,
            level: 1,
            hints: 3,
            isPlaying: true,
            currentCable: null,
            connectionsMade: []
        };
        
        // Device configurations
        const deviceTypes = {
            pc: { icon: 'üíª', ports: 1, connections: ['ethernet', 'crossover'] },
            switch: { icon: 'üîÄ', ports: 4, connections: ['ethernet'] },
            router: { icon: 'üì°', ports: 2, connections: ['ethernet', 'fiber'] }
        };
        
        // Level configurations
        const levels = [
            { devices: [{ type: 'pc', count: 2 }, { type: 'switch', count: 1 }], targetConnections: 2 },
            { devices: [{ type: 'pc', count: 3 }, { type: 'switch', count: 1 }, { type: 'router', count: 1 }], targetConnections: 4 },
            { devices: [{ type: 'pc', count: 4 }, { type: 'switch', count: 2 }, { type: 'router', count: 1 }], targetConnections: 6 },
            { devices: [{ type: 'pc', count: 5 }, { type: 'switch', count: 2 }, { type: 'router', count: 2 }], targetConnections: 8 },
            { devices: [{ type: 'pc', count: 6 }, { type: 'switch', count: 3 }, { type: 'router', count: 2 }], targetConnections: 10 }
        ];
        
        // Initialize game
        function initGame() {
            setupDragAndDrop();
            createDevices();
            startTimer();
            updateUI();
        }
        
        // Create devices based on current level
        function createDevices() {
            const devicesArea = document.getElementById('devicesArea');
            const levelConfig = levels[gameState.level - 1];
            
            // Clear existing devices
            const existingDevices = devicesArea.querySelectorAll('.device');
            existingDevices.forEach(d => d.remove());
            
            // Clear existing connection lines
            const existingLines = devicesArea.querySelectorAll('.connection-line');
            existingLines.forEach(l => l.remove());
            
            let deviceCount = 0;
            const totalDevices = levelConfig.devices.reduce((sum, config) => sum + config.count, 0);
            
            // Responsive device positioning
            const isMobile = window.innerWidth <= 768;
            const devicesPerRow = isMobile ? Math.min(3, totalDevices) : Math.ceil(Math.sqrt(totalDevices));
            const rows = Math.ceil(totalDevices / devicesPerRow);
            
            const areaRect = devicesArea.getBoundingClientRect();
            const rowHeight = (areaRect.height - 100) / (rows + 1);
            const colWidth = areaRect.width / (devicesPerRow + 1);
            
            levelConfig.devices.forEach(config => {
                for (let i = 0; i < config.count; i++) {
                    const row = Math.floor(deviceCount / devicesPerRow);
                    const col = deviceCount % devicesPerRow;
                    
                    const x = col * colWidth + colWidth/2;
                    const y = row * rowHeight + rowHeight/2 + 50; // Add offset for level indicator
                    
                    createDevice(config.type, deviceCount++, x, y);
                }
            });
            
            // Re-setup drag and drop for new ports
            setupPortsEventListeners();
        }
        
        // Create a single device
        function createDevice(type, id, x, y) {
            const devicesArea = document.getElementById('devicesArea');
            const deviceInfo = deviceTypes[type];
            
            const device = document.createElement('div');
            device.className = 'device';
            device.dataset.deviceType = type;
            device.dataset.deviceId = id;
            
            // Responsive device sizing
            const isMobile = window.innerWidth <= 768;
            const deviceSize = isMobile ? 70 : 80;
            const portSize = isMobile ? 16 : 18;
            
            // Position device
            device.style.left = (x - deviceSize/2) + 'px';
            device.style.top = (y - deviceSize/2) + 'px';
            device.style.width = deviceSize + 'px';
            device.style.height = deviceSize + 'px';
            
            device.innerHTML = `
                <div class="device-icon">${deviceInfo.icon}</div>
                <div class="device-name">${type.charAt(0).toUpperCase() + type.slice(1)} ${id + 1}</div>
            `;
            
            // Add ports
            for (let i = 0; i < deviceInfo.ports; i++) {
                const port = document.createElement('div');
                port.className = 'port';
                port.dataset.portId = i;
                port.dataset.deviceId = id;
                port.dataset.deviceType = type;
                port.style.width = portSize + 'px';
                port.style.height = portSize + 'px';
                
                // Position ports around the device
                const angle = (i / deviceInfo.ports) * Math.PI * 2;
                const radius = deviceSize * 0.4;
                const centerX = deviceSize / 2;
                const centerY = deviceSize / 2;
                
                const portX = Math.cos(angle) * radius + centerX - portSize/2;
                const portY = Math.sin(angle) * radius + centerY - portSize/2;
                
                port.style.left = portX + 'px';
                port.style.top = portY + 'px';
                
                device.appendChild(port);
            }
            
            devicesArea.appendChild(device);
        }
        
        // Setup drag and drop
        function setupDragAndDrop() {
            // Cable drag
            const cables = document.querySelectorAll('.cable-item');
            cables.forEach(cable => {
                cable.addEventListener('dragstart', handleCableDragStart);
                cable.addEventListener('dragend', handleCableDragEnd);
                
                // Touch events for mobile
                cable.addEventListener('touchstart', handleCableTouchStart, {passive: false});
                cable.addEventListener('touchmove', handleCableTouchMove, {passive: false});
                cable.addEventListener('touchend', handleCableTouchEnd);
                
                // Click events for mobile
                cable.addEventListener('click', handleCableClick);
            });
            
            // Setup port event listeners
            setupPortsEventListeners();
        }
        
        // Setup event listeners for ports
        function setupPortsEventListeners() {
            const ports = document.querySelectorAll('.port');
            ports.forEach(port => {
                // Remove existing event listeners to avoid duplicates
                port.removeEventListener('dragover', handlePortDragOver);
                port.removeEventListener('drop', handlePortDrop);
                port.removeEventListener('dragleave', handlePortDragLeave);
                port.removeEventListener('click', handlePortClick);
                port.removeEventListener('touchstart', handlePortTouchStart, {passive: false});
                
                // Add new event listeners
                port.addEventListener('dragover', handlePortDragOver);
                port.addEventListener('drop', handlePortDrop);
                port.addEventListener('dragleave', handlePortDragLeave);
                port.addEventListener('click', handlePortClick);
                port.addEventListener('touchstart', handlePortTouchStart, {passive: false});
            });
        }
        
        let draggedCable = null;
        let selectedPort = null;
        let touchItem = null;
        
        function handleCableDragStart(e) {
            draggedCable = e.target.dataset.cableType;
            e.target.classList.add('dragging');
        }
        
        function handleCableDragEnd(e) {
            e.target.classList.remove('dragging');
        }
        
        // Handle cable click for mobile
        function handleCableClick(e) {
            const cableItem = e.target.closest('.cable-item');
            if (!cableItem) return;
            
            // Remove selected class from all cables
            document.querySelectorAll('.cable-item').forEach(cable => {
                cable.classList.remove('selected');
            });
            
            // Set this cable as selected
            cableItem.classList.add('selected');
            draggedCable = cableItem.dataset.cableType;
            
            showMessage('Cable selected!', 'info', 'Now tap on a device port to connect');
        }
        
        // Touch events for cables
        function handleCableTouchStart(e) {
            e.preventDefault();
            touchItem = e.target.closest('.cable-item');
            draggedCable = touchItem.dataset.cableType;
            
            // Remove selected class from all cables
            document.querySelectorAll('.cable-item').forEach(cable => {
                cable.classList.remove('selected');
            });
            
            // Set this cable as selected
            touchItem.classList.add('selected');
            touchItem.style.opacity = '0.5';
        }
        
        function handleCableTouchMove(e) {
            e.preventDefault();
        }
        
        function handleCableTouchEnd(e) {
            e.preventDefault();
            if (touchItem) {
                touchItem.style.opacity = '';
            }
        }
        
        function handlePortDragOver(e) {
            e.preventDefault();
            e.target.classList.add('highlight');
        }
        
        function handlePortDragLeave(e) {
            e.target.classList.remove('highlight');
        }
        
        function handlePortDrop(e) {
            e.preventDefault();
            e.target.classList.remove('highlight');
            
            if (!selectedPort) {
                selectedPort = e.target;
                selectedPort.classList.add('highlight');
                showMessage('Select another port to connect', 'info', 'Choose the second port for the connection');
            } else {
                // Make connection
                const connection = {
                    cable: draggedCable,
                    port1: selectedPort,
                    port2: e.target
                };
                
                if (isValidConnection(connection)) {
                    makeConnection(connection);
                } else {
                    wrongConnection();
                }
                
                selectedPort.classList.remove('highlight');
                selectedPort = null;
            }
        }
        
        function handlePortClick(e) {
            if (!draggedCable) {
                showMessage('Select a cable first', 'warning', 'Tap a cable type from the panel');
                return;
            }
            
            e.target.classList.add('highlight');
            
            if (!selectedPort) {
                selectedPort = e.target;
                showMessage('Select another port to connect', 'info', 'Choose the second port for the connection');
            } else {
                // Make connection
                const connection = {
                    cable: draggedCable,
                    port1: selectedPort,
                    port2: e.target
                };
                
                if (isValidConnection(connection)) {
                    makeConnection(connection);
                } else {
                    wrongConnection();
                }
                
                selectedPort.classList.remove('highlight');
                e.target.classList.remove('highlight');
                selectedPort = null;
            }
        }
        
        function handlePortTouchStart(e) {
            e.preventDefault();
            handlePortClick(e);
        }
        
        // Validate connection
        function isValidConnection(connection) {
            const device1 = connection.port1.dataset.deviceType;
            const device2 = connection.port2.dataset.deviceType;
            const cable = connection.cable;
            
            // Check if devices are different
            if (connection.port1.dataset.deviceId === connection.port2.dataset.deviceId) {
                return false;
            }
            
            // Check if connection already exists
            const connectionKey = `${connection.port1.dataset.deviceId}-${connection.port2.dataset.deviceId}`;
            const reverseConnectionKey = `${connection.port2.dataset.deviceId}-${connection.port1.dataset.deviceId}`;
            if (gameState.connectionsMade.includes(connectionKey) || gameState.connectionsMade.includes(reverseConnectionKey)) {
                return false;
            }
            
            // Check cable compatibility
            const device1Info = deviceTypes[device1];
            const device2Info = deviceTypes[device2];
            
            if (!device1Info.connections.includes(cable) || !device2Info.connections.includes(cable)) {
                return false;
            }
            
            // Special rules
            if (cable === 'crossover' && (device1 !== 'pc' || device2 !== 'pc')) {
                return false;
            }
            
            if (cable === 'fiber' && (device1 !== 'router' || device2 !== 'router')) {
                return false;
            }
            
            return true;
        }
        
        // Make valid connection
        function makeConnection(connection) {
            connection.port1.classList.add('connected');
            connection.port2.classList.add('connected');
            
            // Create visual connection line
            createConnectionLine(connection.port1, connection.port2, connection.cable);
            
            // Update game state
            gameState.connections++;
            const pointsEarned = 50 * gameState.level;
            const coinsEarned = 25 * gameState.level;
            gameState.score += 100 * gameState.level;
            gameState.points += pointsEarned;
            gameState.coins += coinsEarned;
            gameState.connectionsMade.push(
                `${connection.port1.dataset.deviceId}-${connection.port2.dataset.deviceId}`
            );
            
            // Create particles
            createParticles(connection.port1);
            createParticles(connection.port2);
            
            updateUI();
            
            // Check win condition
            if (gameState.connections >= levels[gameState.level - 1].targetConnections) {
                levelComplete();
            }
        }
        
        // Create visual connection line
        function createConnectionLine(port1, port2, cableType) {
            const devicesArea = document.getElementById('devicesArea');
            const line = document.createElement('div');
            line.className = 'connection-line';
            
            const rect1 = port1.getBoundingClientRect();
            const rect2 = port2.getBoundingClientRect();
            const areaRect = devicesArea.getBoundingClientRect();
            
            const x1 = rect1.left + rect1.width / 2 - areaRect.left;
            const y1 = rect1.top + rect1.height / 2 - areaRect.top;
            const x2 = rect2.left + rect2.width / 2 - areaRect.left;
            const y2 = rect2.top + rect2.height / 2 - areaRect.top;
            
            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            
            line.style.width = length + 'px';
            line.style.height = '4px';
            line.style.left = x1 + 'px';
            line.style.top = y1 + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.transformOrigin = '0 50%';
            
            // Set cable color
            if (cableType === 'ethernet') line.style.background = '#ff6b6b';
            else if (cableType === 'fiber') line.style.background = '#4ecdc4';
            else if (cableType === 'crossover') line.style.background = '#ffe66d';
            
            devicesArea.appendChild(line);
        }
        
        // Handle wrong connection
        function wrongConnection() {
            gameState.timeLeft -= 5;
            gameState.score = Math.max(0, gameState.score - 50);
            gameState.points = Math.max(0, gameState.points - 25);
            gameState.coins = Math.max(0, gameState.coins - 10);
            updateUI();
            showMessage('Wrong Connection!', 'error', 'Time penalty! -5 seconds');
            
            // Shake effect
            const devicesArea = document.getElementById('devicesArea');
            devicesArea.style.animation = 'shake 0.5s';
            setTimeout(() => {
                devicesArea.style.animation = '';
            }, 500);
        }
        
        // Create particle effects
        function createParticles(element) {
            const rect = element.getBoundingClientRect();
            const devicesArea = document.getElementById('devicesArea');
            const areaRect = devicesArea.getBoundingClientRect();
            
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = (rect.left - areaRect.left + rect.width / 2) + 'px';
                particle.style.top = (rect.top - areaRect.top + rect.height / 2) + 'px';
                particle.style.transform = `rotate(${Math.random() * 360}deg)`;
                devicesArea.appendChild(particle);
                
                setTimeout(() => particle.remove(), 1000);
            }
        }
        
        // Timer
        let timerInterval;
        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (gameState.isPlaying && gameState.timeLeft > 0) {
                    gameState.timeLeft--;
                    updateUI();
                    
                    if (gameState.timeLeft <= 10) {
                        document.getElementById('timer').classList.add('warning');
                    }
                    
                    if (gameState.timeLeft === 0) {
                        gameOver();
                    }
                }
            }, 1000);
        }
        
        // Show hint
        function showHint() {
            if (gameState.hints > 0) {
                gameState.hints--;
                document.getElementById('hintBtn').textContent = `üí° Hint (${gameState.hints})`;
                
                // Find a valid connection and highlight ports
                const ports = document.querySelectorAll('.port:not(.connected)');
                for (let i = 0; i < ports.length; i++) {
                    for (let j = i + 1; j < ports.length; j++) {
                        const connection = {
                            cable: 'ethernet', // Default to ethernet for hint
                            port1: ports[i],
                            port2: ports[j]
                        };
                        
                        if (isValidConnection(connection)) {
                            ports[i].classList.add('highlight');
                            ports[j].classList.add('highlight');
                            setTimeout(() => {
                                ports[i].classList.remove('highlight');
                                ports[j].classList.remove('highlight');
                            }, 3000);
                            return;
                        }
                    }
                }
                
                showMessage('No valid connections found!', 'warning', 'Check your cable types');
            }
        }
        
        // Reset level
        function resetLevel() {
            clearInterval(timerInterval);
            gameState.connections = 0;
            gameState.connectionsMade = [];
            gameState.timeLeft = 60 + (gameState.level * 10);
            gameState.isPlaying = true;
            selectedPort = null;
            
            // Clear selected cable
            document.querySelectorAll('.cable-item').forEach(cable => {
                cable.classList.remove('selected');
            });
            draggedCable = null;
            
            createDevices();
            startTimer();
            updateUI();
        }
        
        // Record reward to database
        async function recordReward(points, coins, reason) {
            const username = localStorage.getItem("loggedInUser");
            if (!username) {
                console.log("No username found in localStorage. Cannot record reward.");
                return;
            }
            try {
                const response = await fetch("https://postgres-test-p05s.onrender.com/api/reward", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        username,
                        points,
                        coins,
                        reason
                    })
                });
                const data = await response.json();
                if (data.success) {
                    console.log(`Reward recorded: +${points} Points, +${coins} Coins`);
                } else {
                    console.error("Reward API failed:", data);
                }
            } catch (err) {
                console.error("Reward API Error:", err);
            }
        }
        
        // Level complete
        function levelComplete() {
            clearInterval(timerInterval);
            gameState.isPlaying = false;
            
            const bonus = gameState.timeLeft * 10;
            const pointsBonus = gameState.timeLeft * 5;
            const coinsBonus = gameState.timeLeft * 3;
            gameState.score += bonus;
            gameState.points += pointsBonus;
            gameState.coins += coinsBonus;
            
            // Record level completion reward to database
            recordReward(pointsBonus, coinsBonus, `Completed Level ${gameState.level}`);
            
            showMessage('Level Complete!', 'success', `Bonus: +${bonus} points! +${pointsBonus} stars! +${coinsBonus} coins!`);
            
            setTimeout(() => {
                if (gameState.level < levels.length) {
                    gameState.level++;
                    gameState.timeLeft = 60 + (gameState.level * 10);
                    gameState.connections = 0;
                    gameState.connectionsMade = [];
                    gameState.isPlaying = true;
                    selectedPort = null;
                    
                    // Clear selected cable
                    document.querySelectorAll('.cable-item').forEach(cable => {
                        cable.classList.remove('selected');
                    });
                    draggedCable = null;
                    
                    createDevices();
                    startTimer();
                    updateUI();
                } else {
                    gameWin();
                }
            }, 2000);
        }
        
        // Game over
        function gameOver() {
            clearInterval(timerInterval);
            gameState.isPlaying = false;
            showMessage('Game Over!', 'error', `Final Score: ${gameState.score} | Stars: ${gameState.points} | Coins: ${gameState.coins}`);
        }
        
        // Game win
        function gameWin() {
            // Record game completion reward to database
            recordReward(gameState.points, gameState.coins, "Completed all levels");
            
            showMessage('Congratulations!', 'success', `You completed all levels! Final Score: ${gameState.score} | Stars: ${gameState.points} | Coins: ${gameState.coins}`);
        }
        
        // Show message
        function showMessage(title, type, text) {
            const message = document.getElementById('message');
            const messageTitle = document.getElementById('messageTitle');
            const messageText = document.getElementById('messageText');
            
            message.className = `message ${type} show`;
            messageTitle.textContent = title;
            messageText.textContent = text;
        }
        
        // Hide message
        function hideMessage() {
            const message = document.getElementById('message');
            message.classList.remove('show');
        }
        
        // Update UI
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('points').textContent = gameState.points;
            document.getElementById('coins').textContent = gameState.coins;
            document.getElementById('timer').textContent = gameState.timeLeft;
            document.getElementById('level').textContent = gameState.level;
            
            // Update hint button
            document.getElementById('hintBtn').disabled = gameState.hints === 0;
        }
        
        // Show confirmation dialog
        function showConfirmDialog() {
            const dialog = document.getElementById('confirmDialog');
            dialog.classList.add('show');
        }
        
        // Hide confirmation dialog
        function hideConfirmDialog() {
            const dialog = document.getElementById('confirmDialog');
            dialog.classList.remove('show');
        }
        
        // Quit game and redirect
        function quitGame() {
            // Stop the timer
            clearInterval(timerInterval);
            
            // Redirect to the levels page
            window.location.href = '../levels/networkinglevels.html';
        }
        
        // Add shake animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-10px); }
                75% { transform: translateX(10px); }
            }
        `;
        document.head.appendChild(style);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            createDevices();
        });
        
        // Initialize game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
    @keyframes glitch-2 {
      0%, 100% { 
        clip-path: inset(0 0 0 0); 
        transform: translate(0); 
        opacity: 0;
      }
      10% { 
        opacity: 0.7;
      }
      20% { 
        clip-path: inset(60% 0 10% 0); 
        transform: translate(2px); 
        opacity: 0.7;
      }
      30% {
        opacity: 0;
      }
      40% { 
        clip-path: inset(20% 0 50% 0); 
        transform: translate(-2px); 
        opacity: 0.7;
      }
      50% {
        opacity: 0;
      }
      60% { 
        clip-path: inset(30% 0 40% 0); 
        transform: translate(0); 
        opacity: 0.7;
      }
      70% {
        opacity: 0;
      }
      80% { 
        clip-path: inset(5% 0 80% 0); 
        transform: translate(2px); 
        opacity: 0.7;
      }
      90% {
        opacity: 0;
      }
    }
    
    .back-button { 
      cursor: pointer; 
      font-size: 20px; 
      color: #ff00ff;
      transition: transform 0.2s ease, color 0.3s ease;
    }
    
    .back-button:hover { 
      transform: scale(1.2) rotate(-30deg); 
      color: #ff5eff;
    }
    
    .placeholder { width: 30px; }
    
    .instructions { 
      max-width: 800px;
      background: rgba(0, 30, 60, 0.7); 
      border: 1px solid #0056b3; 
      border-radius: 4px; 
      padding: 15px 20px; 
      margin: 10px 20px; 
      font-size: 14px; 
      line-height: 1.5; 
      color: #e0f7fa; 
      animation: fadeIn 1.2s ease-in-out;
      box-shadow: 0 0 15px rgba(0, 86, 179, 0.2);
      position: relative;
      overflow: hidden;
    }
    
    .instructions::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, transparent, #00e5ff, transparent);
      animation: scan-line 3s linear infinite;
    }
    
    .instructions strong { color: #00e5ff; }
    
    .tutorial-box { 
      margin: 15px auto; 
      padding: 12px 15px; 
      border: 1px solid #0056b3; 
      border-radius: 4px; 
      background: rgba(0, 20, 40, 0.8); 
      box-shadow: 0 0 10px rgba(0, 86, 179, 0.3); 
      text-align: center; 
      max-width: 500px; 
      min-height: 80px;
      position: relative;
      overflow: hidden;
    }
    
    .tutorial-box::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        90deg,
        transparent,
        transparent 2px,
        rgba(0, 229, 255, 0.05) 2px,
        rgba(0, 229, 255, 0.05) 4px
      );
      z-index: -1;
    }
    
    .tutorial-step { 
      font-size: 14px; 
      color: #e0f7fa; 
      opacity: 0; 
      transform: translateY(10px); 
      transition: opacity 0.6s ease, transform 0.6s ease; 
      position: relative;
    }
    
    .tutorial-step.active { 
      opacity: 1; 
      transform: translateY(0); 
      color: #00e5ff; 
      animation: typing 1.5s steps(20, end);
    }
    
    .video-caption { 
      font-size: 13px; 
      margin-top: 8px; 
      color: #90caf9; 
      font-style: italic; 
    }
    
    .start-btn { 
      margin-top: 20px; 
      padding: 10px 18px; 
      font-size: 16px; 
      font-weight: bold; 
      background: linear-gradient(45deg, #9527ae, #00ffff);
      color: #ffffff; 
      border: none; 
      border-radius: 8px; 
      cursor: pointer; 
      transition: 0.2s;
      font-family: 'Poppins', sans-serif;
      box-shadow: 0 0 8px rgba(0, 86, 179, 0.5);
      position: relative;
      overflow: hidden;
    }
    
    .start-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }
    
    .start-btn:hover::before {
      left: 100%;
    }
    
    .start-btn:hover { 
      background: linear-gradient(45deg, #219150, #ff00ff); 
      color: #ffffff; 
      box-shadow: 0 0 12px rgba(0, 229, 255, 0.7); 
    }
    
    .game-section { 
      display: none; 
      flex-direction: column; 
      align-items: center; 
      width: 100%; 
      opacity: 0; 
      animation: fadeIn 1s ease forwards; 
    }
    
    .timer { 
      font-size: 16px; 
      margin-bottom: 12px; 
      color: #00e5ff; 
      animation: pulse 2s infinite;
      text-shadow: 0 0 5px rgba(0, 229, 255, 0.7);
      font-family: 'Poppins', sans-serif;
    }
    
    .game { 
      display: flex; 
      position: relative; 
      justify-content: center; 
      width: 95%; 
      max-width: 1000px; 
      height: 600px; 
      margin: 0 auto;
    }
    
    #lineCanvas { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%;
      height: 100%;
      z-index: 2; 
      pointer-events: none; 
    }
    
    .column { 
      display: flex; 
      flex-direction: column; 
      gap: 18px; 
      padding: 10px; 
      z-index: 1; 
      justify-content: space-around;
    }
    
    #pinColumn { 
      margin-right: auto; 
      align-items: flex-end; 
    }
    
    #wireColumn { 
      margin-left: auto; 
      align-items: flex-start; 
    }
    
    .slot, .wire {
      position: relative;
      padding: 10px 15px; 
      border-radius: 6px; 
      font-size: 14px; 
      font-weight: bold;
      cursor: grab;
      user-select: none;
      width: 90px; 
      text-align: center;
      transition: transform 0.2s ease, box-shadow 0.3s ease;
      font-family: 'Poppins', sans-serif;
    }
    
    .slot { 
      background: rgba(0, 30, 60, 0.7); 
      border: 1px dashed #0056b3; 
      color: #e0f7fa; 
    }
    
    .slot.active {
      border: 1px solid #39ff14;
      box-shadow: 0 0 15px rgba(57, 255, 20, 0.7);
      animation: portGlow 1.5s infinite alternate;
    }
    
    @keyframes portGlow {
      from { box-shadow: 0 0 15px rgba(57, 255, 20, 0.7); }
      to { box-shadow: 0 0 25px rgba(0, 229, 255, 0.7); }
    }
    
    .slot.hover { 
      box-shadow: 0 0 10px rgba(0, 229, 255, 0.5); 
      transform: scale(1.05); 
    }
    
    .wire { 
      color: #0a1929; 
      border: 1px solid #0056b3; 
      background: #e0f7fa; 
      transition: transform 0.2s ease; 
    }
    
    .wire:active { 
      transform: scale(1.1); 
    }
    
    .wire.correct { 
      animation: glow 1s infinite alternate, pulse-success 1.5s infinite; 
    }
    
    .wire.incorrect { 
      animation: shake 0.4s, error-flash 0.5s; 
    }
    
    /* New style for placed wires */
    .wire.placed {
      opacity: 0.6;
      cursor: default;
      pointer-events: none;
      box-shadow: 0 0 8px rgba(57, 255, 20, 0.5);
    }
    
    .pin-dot { 
      position: absolute; 
      top: 50%; 
      transform: translateY(-50%); 
      width: 16px; 
      height: 16px; 
      border-radius: 50%; 
      background: #00e5ff;
      box-shadow: 0 0 5px rgba(0, 229, 255, 0.7);
    }
    
    .slot .pin-dot { 
      right: -12px; 
    }
    
    .wire .pin-dot { 
      left: -12px; 
    }
    
    .submit-btn {
      margin: 20px;
      padding: 12px 20px; 
      background: linear-gradient(45deg, #9527ae, #00ffff);
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      transition: 0.2s;
      font-size: 16px; 
      color: #ffffff;
      font-family: 'Poppins', sans-serif;
      box-shadow: 0 0 8px rgba(0, 86, 179, 0.5);
      position: relative;
      overflow: hidden;
    }
    
    .submit-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }
    
    .submit-btn:hover::before {
      left: 100%;
    }
    
    .submit-btn:hover { 
      background: linear-gradient(45deg, #219150, #ff00ff); 
      color: #ffffff; 
      box-shadow: 0 0 12px rgba(0, 229, 255, 0.7); 
    }
    
    #result { 
      font-size: 18px; 
      font-weight: bold; 
      margin: 8px; 
      text-align: center; 
      font-family: 'Poppins', sans-serif;
    }
    
    /* Data Packets */
    .data-packet {
      position: absolute;
      width: 10px; 
      height: 10px; 
      background: #39ff14;
      border-radius: 50%;
      box-shadow: 0 0 10px #39ff14;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
    }
    
    /* Animations */
    @keyframes fadeIn { 
      from { opacity: 0; transform: translateY(10px); } 
      to { opacity: 1; transform: translateY(0); } 
    }
    
    @keyframes pulse { 
      0% { text-shadow: 0 0 5px rgba(0, 229, 255, 0.7); } 
      50% { text-shadow: 0 0 15px rgba(0, 229, 255, 0.9); } 
      100% { text-shadow: 0 0 5px rgba(0, 229, 255, 0.7); } 
    }
    
    @keyframes shake { 
      0% { transform: translateX(0); } 
      25% { transform: translateX(-5px); } 
      50% { transform: translateX(5px); } 
      75% { transform: translateX(-5px); } 
      100% { transform: translateX(0); } 
    }
    
    @keyframes scan-line {
      0% { transform: translateY(-100%); }
      100% { transform: translateY(100%); }
    }
    
    @keyframes typing {
      from { width: 0; }
      to { width: 100%; }
    }
    
    @keyframes pulse-success {
      0% { box-shadow: 0 0 5px rgba(0, 229, 255, 0.7); }
      50% { box-shadow: 0 0 15px rgba(0, 229, 255, 0.9), 0 0 20px rgba(0, 229, 255, 0.5); }
      100% { box-shadow: 0 0 5px rgba(0, 229, 255, 0.7); }
    }
    
    @keyframes error-flash {
      0%, 100% { background-color: #e0f7fa; }
      25%, 75% { background-color: #ffcccc; }
      50% { background-color: #ff9999; }
    }
    
    @keyframes dataFlow {
      0% { opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      header {
        padding: 12px 15px;
      }
      
      .header-title {
        font-size: 16px;
      }
      
      .back-button {
        font-size: 18px;
      }
      
      .instructions {
        margin: 10px 15px;
        padding: 12px 15px;
        font-size: 13px;
      }
      
      .tutorial-box {
        margin: 10px auto;
        padding: 10px 12px;
        max-width: 90%;
      }
      
      .tutorial-step {
        font-size: 13px;
      }
      
      .start-btn {
        padding: 8px 15px;
        font-size: 14px;
      }
      
      .game {
        width: 95%;
        height: 550px; /* Increased from 450px */
      }
      
      .slot, .wire {
        width: 85px; /* Increased from 70px */
        font-size: 13px; /* Increased from 12px */
        padding: 10px 12px; /* Increased from 8px 10px */
      }
      
      .pin-dot {
        width: 16px; /* Increased from 14px */
        height: 16px; /* Increased from 14px */
      }
      
      .slot .pin-dot {
        right: -12px; /* Adjusted from -10px */
      }
      
      .wire .pin-dot {
        left: -12px; /* Adjusted from -10px */
      }
      
      .submit-btn {
        padding: 12px 18px; /* Increased from 10px 16px */
        font-size: 15px; /* Increased from 14px */
      }
    }
    
    /* Small mobile devices */
    @media (max-width: 480px) {
      /* Header adjustments */
      header {
        padding: 15px 10px;
      }
      
      .header-title {
        font-size: 18px; /* Increased for better readability */
      }
      
      .back-button {
        font-size: 24px; /* Larger back button for easier tapping */
      }
      
      /* Instructions section */
      .instructions {
        font-size: 15px; /* Larger text for better readability */
        padding: 15px; /* More padding for better spacing */
        margin: 10px 15px;
      }
      
      .instructions strong {
        font-size: 17px; /* Emphasized headings */
      }
      
      /* Tutorial box - made significantly larger */
      .tutorial-box {
        padding: 20px; /* Increased from 15px */
        margin: 15px auto;
        max-width: 95%; /* Increased from 90% */
        min-height: 100px; /* Increased from 80px */
      }
      
      .tutorial-step {
        font-size: 16px; /* Increased from 15px */
      }
      
      .video-caption {
        font-size: 14px; /* Increased caption size */
      }
      
      /* Buttons - made larger for easier tapping */
      .start-btn, .submit-btn {
        font-size: 18px; /* Larger button text */
        padding: 15px 25px; /* More padding for larger touch targets */
      }
      
      /* Game elements */
      .timer {
        font-size: 18px; /* Larger timer text */
      }
      
      .game {
        height: 500px; /* Increased from 480px */
      }
      
      .slot, .wire {
        font-size: 16px; /* Increased from 14px */
        padding: 14px 16px; /* Increased from 12px 15px */
        width: 100px; /* Increased from 80px */
      }
      
      #result {
        font-size: 20px; /* Larger result text */
      }
      
      /* Pin dots - made larger */
      .pin-dot {
        width: 20px; /* Increased from 18px */
        height: 20px; /* Increased from 18px */
      }
      
      .slot .pin-dot {
        right: -16px; /* Adjusted from -14px */
      }
      
      .wire .pin-dot {
        left: -16px; /* Adjusted from -14px */
      }
    }
    
    /* Extra small mobile devices */
    @media (max-width: 360px) {
      .game {
        height: 480px; /* Increased from 450px */
      }
      
      .slot, .wire {
        width: 90px; /* Increased from 65px */
        font-size: 14px; /* Increased from 11px */
        padding: 12px 14px; /* Increased from 7px 8px */
      }
      
      .pin-dot {
        width: 18px; /* Increased from 12px */
        height: 18px; /* Increased from 12px */
      }
      
      .slot .pin-dot {
        right: -14px; /* Increased from -8px */
      }
      
      .wire .pin-dot {
        left: -14px; /* Increased from -8px */
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
</head>
<body>
  <!-- Digital Rain Background -->
  <canvas class="digital-rain" id="digitalRain"></canvas>
  
  <!-- Circuit Board Pattern -->
  <div class="circuit-board"></div>
  
  <!-- Circuit Traces -->
  <div class="circuit-traces" id="circuitTraces"></div>
  
  <!-- Floating Particles -->
  <div class="particles" id="particles"></div>
  
  <!-- Header with Back Button -->
  <header>
    <div class="back-button" onclick="window.location.href='../levels/networkinglevels.html'">‚§∫</div>
    <div class="header-title">Networking Easy Level - Straight Through</div>
    <div class="placeholder"></div>
  </header>
  
  <!-- Instructions -->
  <div class="instructions" id="instructions">
    <p><strong>Instructions:</strong></p>
    <ul>
      <li>Drag each <strong>wire</strong> from the right column and drop it onto the correct <strong>pin</strong> (1‚Äì8).</li>
      <li>The correct wiring sequence follows the <strong>Straight Through standard</strong>.</li>
      <li>You have <strong>1 minute</strong> to complete the task.</li>
      <li>Click <strong>Submit</strong> to check your connections.</li>
    </ul>
    <div class="tutorial-box" id="tutorialBox">
      <div class="tutorial-step active">üëã Welcome! This is a quick demo.</div>
      <div class="tutorial-step">‚û° Drag a wire from the right side.</div>
      <div class="tutorial-step">‚¨Ö Drop it onto the correct pin (1‚Äì8).</div>
      <div class="tutorial-step">‚úÖ Match all 8 wires using Straight Through68B order.</div>
      <div class="tutorial-step">‚ñ∂ Click "Start Game" when ready!</div>
    </div>
    <p class="video-caption">üìò Steps auto-play below instead of video</p>
    <button class="start-btn" onclick="startGame()">‚ñ∂ Start Game</button>
  </div>
  
  <!-- Game Section -->
  <div class="game-section" id="gameSection">
    <div class="timer">‚è≥ Time left: <span id="countdown">1:00</span></div>
    <div class="game">
      <canvas id="lineCanvas"></canvas>
      <div class="column" id="pinColumn"></div>
      <div class="column" id="wireColumn"></div>
    </div>
    <button class="submit-btn" onclick="checkWiring()">Submit</button>
    <div id="result"></div>
  </div>
  
  <script>
    // Create floating particles
    const particlesContainer = document.getElementById('particles');
    const particleCount = 15; // Reduced from 30 to improve performance
    
    for (let i = 0; i < particleCount; i++) {
      const particle = document.createElement('div');
      particle.className = 'particle';
      
      // Random size between 2px and 6px
      const size = Math.random() * 4 + 2;
      particle.style.width = `${size}px`;
      particle.style.height = `${size}px`;
      
      // Random position
      particle.style.left = `${Math.random() * 100}%`;
      particle.style.top = `${Math.random() * 100}%`;
      
      // Random animation delay
      particle.style.animationDelay = `${Math.random() * 15}s`;
      
      particlesContainer.appendChild(particle);
    }
    
    // Create circuit traces
    const circuitTraces = document.getElementById('circuitTraces');
    const traceCount = 8; // Reduced from 15 to improve performance
    
    for (let i = 0; i < traceCount; i++) {
      const trace = document.createElement('div');
      trace.className = 'circuit-trace';
      trace.style.top = `${Math.random() * 100}%`;
      trace.style.width = `${Math.random() * 30 + 10}%`;
      trace.style.animationDelay = `${Math.random() * 8}s`;
      trace.style.animationDuration = `${Math.random() * 5 + 5}s`;
      circuitTraces.appendChild(trace);
    }
    
    // Digital Rain Effect (Purely Visual)
    const rainCanvas = document.getElementById('digitalRain');
    const rainCtx = rainCanvas.getContext('2d');
    
    // Function to set canvas size
    function setCanvasSize() {
      rainCanvas.width = window.innerWidth;
      rainCanvas.height = window.innerHeight;
    }
    
    // Set initial canvas size
    setCanvasSize();
    
    // Characters for the digital rain
    const characters = '01';
    const fontSize = 14;
    let columns = rainCanvas.width / fontSize;
    const drops = [];
    
    // Initialize drops
    for (let i = 0; i < columns; i++) {
      drops[i] = Math.random() * rainCanvas.height;
    }
    
    // Draw the digital rain
    function drawRain() {
      rainCtx.fillStyle = 'rgba(10, 25, 41, 0.05)';
      rainCtx.fillRect(0, 0, rainCanvas.width, rainCanvas.height);
      
      rainCtx.fillStyle = '#00e5ff';
      rainCtx.font = `${fontSize}px monospace`;
      
      for (let i = 0; i < drops.length; i++) {
        const text = characters.charAt(Math.floor(Math.random() * characters.length));
        rainCtx.fillText(text, i * fontSize, drops[i] * fontSize);
        
        if (drops[i] * fontSize > rainCanvas.height && Math.random() > 0.975) {
          drops[i] = 0;
        }
        
        drops[i]++;
      }
    }
    
    // Animation loop for digital rain with reduced frame rate
    let rainAnimationId;
    function startRainAnimation() {
      if (rainAnimationId) {
        cancelAnimationFrame(rainAnimationId);
      }
      
      function animate() {
        drawRain();
        rainAnimationId = requestAnimationFrame(animate);
      }
      
      // Run at lower frame rate to improve performance
      setInterval(() => {
        if (rainAnimationId) {
          animate();
        }
      }, 100);
    }
    
    startRainAnimation();
    
    // Resize canvas when window is resized
    window.addEventListener('resize', () => {
      setCanvasSize();
      // Recalculate columns after resize
      columns = rainCanvas.width / fontSize;
      // Reinitialize drops array for new canvas size
      drops.length = 0;
      for (let i = 0; i < columns; i++) {
        drops[i] = Math.random() * rainCanvas.height;
      }
    });
    
    // === Tutorial ===
    const steps = document.querySelectorAll(".tutorial-step");
    let stepIndex = 0;
    setInterval(() => {
      steps.forEach((s, i) => s.classList.toggle("active", i === stepIndex));
      stepIndex = (stepIndex + 1) % steps.length;
    }, 3000);
    
    // === Game Variables (Original Backend Logic) ===
    const canvas = document.getElementById('lineCanvas');
    const ctx = canvas.getContext('2d');
    let startWire = null;
    let connections = [];
    let timeLeft = 120;
    let timerStarted = false;
    let timer;
    const countdownEl = document.getElementById('countdown');
    const resultEl = document.getElementById('result');
    
    // Animation variables for data flow
    let animationProgress = 0;
    let animationId = null;
    
    // Function to set game canvas size
    function setGameCanvasSize() {
      const gameContainer = document.querySelector('.game');
      canvas.width = gameContainer.offsetWidth;
      canvas.height = gameContainer.offsetHeight;
    }
    
    function startGame() {
      document.getElementById("instructions").style.display = "none";
      const section = document.getElementById("gameSection");
      section.style.display = "flex";
      section.style.animation = "fadeIn 1s ease forwards";
      
      // Set canvas size when starting the game
      setGameCanvasSize();
      
      startAnimation();
      // üéµ Start background music
      startGameMusic();
    }
    
    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      return `${m}:${s < 10 ? '0' : ''}${s}`;
    }
    
    function startTimer() {
      if (timerStarted) return;
      timerStarted = true;
      countdownEl.textContent = formatTime(timeLeft);
      timer = setInterval(() => {
        timeLeft--;
        countdownEl.textContent = formatTime(timeLeft);
        if (timeLeft <= 0) {
          clearInterval(timer);
          alert("‚è∞ Time's up! Try again.");
          location.reload();
        }
      }, 1000);
    }
    
    // Build pin slots (Original Backend Logic)
    const pins = document.getElementById('pinColumn');
    for (let i = 1; i <= 8; i++) {
      const slot = document.createElement('div');
      slot.className = 'slot';
      slot.dataset.pin = i;
      slot.innerHTML = `Pin ${i} <span class="pin-dot"></span>`;
      pins.appendChild(slot);
      slot.addEventListener('dragover', e => { 
        e.preventDefault(); 
        slot.classList.add('hover'); 
      });
      slot.addEventListener('dragleave', () => { 
        slot.classList.remove('hover'); 
      });
      slot.addEventListener('drop', (e) => {
        e.preventDefault();
        slot.classList.remove('hover');
        
        // Check if wire is already placed
        if (startWire.classList.contains('placed')) {
          return;
        }
        
        const pin = slot.getAttribute('data-pin');
        const color = startWire.getAttribute('data-color');
        
        // Check if this pin already has a wire
        const existingConnection = connections.find(c => c.pin === pin);
        if (existingConnection) {
          // Remove the existing connection and make the wire available again
          existingConnection.wire.classList.remove('placed');
          existingConnection.wire.draggable = true;
          existingConnection.wire.style.cursor = 'grab';
          // Remove active class from the slot
          document.querySelector(`.slot[data-pin="${pin}"]`).classList.remove('active');
        }
        
        // Check if this wire is already connected to another pin
        const wireConnection = connections.find(c => c.color === color);
        if (wireConnection) {
          // Remove the connection and make the wire available again
          wireConnection.wire.classList.remove('placed');
          wireConnection.wire.draggable = true;
          wireConnection.wire.style.cursor = 'grab';
          // Remove active class from the previous slot
          document.querySelector(`.slot[data-pin="${wireConnection.pin}"]`).classList.remove('active');
        }
        
        // Filter out the old connections for this pin and wire
        connections = connections.filter(c => c.pin !== pin && c.color !== color);
        
        // Add the new connection
        connections.push({ pin, color, wire: startWire });
        
        // Mark the wire as placed
        startWire.classList.add('placed');
        startWire.draggable = false;
        startWire.style.cursor = 'default';
        
        // Add active class to the slot
        slot.classList.add('active');
        
        drawConnections();
        
        // Create data packet animation for correct connections
        if (isCorrectConnection(pin, color)) {
          createDataPacket(pin, color);
        }
      });
    }
    
    // Check if connection is correct
    function isCorrectConnection(pin, color) {
      const correctOrder = [
        'White-Orange', 'Orange', 'White-Green', 'Blue',
        'White-Blue', 'Green', 'White-Brown', 'Brown'
      ];
      return correctOrder[parseInt(pin) - 1] === color;
    }
    
    // Create animated data packet
    function createDataPacket(pin, color) {
      const packet = document.createElement('div');
      packet.className = 'data-packet';
      document.body.appendChild(packet);
      
      const slot = document.querySelector(`.slot[data-pin="${pin}"]`);
      const wire = connections.find(c => c.pin === pin && c.color === color).wire;
      
      const slotRect = slot.getBoundingClientRect();
      const wireRect = wire.getBoundingClientRect();
      
      const startX = wireRect.left + wireRect.width / 2;
      const startY = wireRect.top + wireRect.height / 2;
      const endX = slotRect.left + slotRect.width / 2;
      const endY = slotRect.top + slotRect.height / 2;
      
      packet.style.left = `${startX}px`;
      packet.style.top = `${startY}px`;
      
      // Animate the packet along the connection
      packet.style.animation = 'dataFlow 2s ease-in-out';
      packet.style.opacity = '1';
      
      // Move the packet from start to end
      setTimeout(() => {
        packet.style.transition = 'all 1.5s cubic-bezier(0.42, 0, 0.58, 1)';
        packet.style.left = `${endX}px`;
        packet.style.top = `${endY}px`;
      }, 100);
      
      // Remove the packet after animation
      setTimeout(() => {
        packet.remove();
      }, 2000);
    }
    
    // Wire colors (Original Backend Logic)
    const wiresData = {
      "White-Orange": "linear-gradient(to right, white 50%, orange 50%)",
      "Orange": "orange",
      "White-Green": "linear-gradient(to right, white 50%, green 50%)",
      "Blue": "blue",
      "White-Blue": "linear-gradient(to right, white 50%, blue 50%)",
      "Green": "green",
      "White-Brown": "linear-gradient(to right, white 50%, brown 50%)",
      "Brown": "brown"
    };
    
    // Shuffle wires (Original Backend Logic)
    const shuffled = Object.keys(wiresData).sort(() => 0.5 - Math.random());
    const wiresContainer = document.getElementById('wireColumn');
    shuffled.forEach(color => {
      const div = document.createElement('div');
      div.className = 'wire';
      div.draggable = true;
      div.dataset.color = color;
      div.style.background = wiresData[color];
      div.innerHTML = `<span class="pin-dot"></span> ${color}`;
      wiresContainer.appendChild(div);
      div.addEventListener('dragstart', (e) => { 
        // Prevent dragging if wire is already placed
        if (div.classList.contains('placed')) {
          e.preventDefault();
          return;
        }
        startWire = div; 
        startTimer(); 
        e.dataTransfer.effectAllowed = 'move';
      });
      div.addEventListener('mousedown', startTimer);
      div.addEventListener('touchstart', startTimer);
    });
    
    // Draw connections with data flow animation (Enhanced but Preserves Original Logic)
    function drawConnections() {
      // Clear canvas completely
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const rect = canvas.getBoundingClientRect();
      
      connections.forEach(conn => {
        const pinDot = document.querySelector(
          `.slot[data-pin="${conn.pin}"] .pin-dot`
        ).getBoundingClientRect();
        const wireDot = conn.wire.querySelector('.pin-dot').getBoundingClientRect();
        const x1 = wireDot.left + wireDot.width / 2 - rect.left;
        const y1 = wireDot.top + wireDot.height / 2 - rect.top;
        const x2 = pinDot.left + pinDot.width / 2 - rect.left;
        const y2 = pinDot.top + pinDot.height / 2 - rect.top;
        
        // Create flowing, loose curves
        const dx = x2 - x1;
        const dy = y2 - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Add natural sag based on wire length and gravity
        const sagAmount = Math.min(distance * 0.3, 80);
        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2 + sagAmount;
        
        // Add slight random variations for natural look
        const variation1X = (Math.random() - 0.5) * 20;
        const variation1Y = (Math.random() - 0.5) * 15;
        const variation2X = (Math.random() - 0.5) * 20;
        const variation2Y = (Math.random() - 0.5) * 15;
        
        const cp1X = x1 + dx * 0.3 + variation1X;
        const cp1Y = y1 + dy * 0.3 + sagAmount * 0.5 + variation1Y;
        const cp2X = x2 - dx * 0.3 + variation2X;
        const cp2Y = y2 - dy * 0.3 + sagAmount * 0.5 + variation2Y;
        
        // Draw the connection line
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, x2, y2);
        ctx.lineWidth = 5; 
        ctx.lineCap = 'round';
        
        // Apply IT theme to connection lines
        if (conn.color.includes('-')) {
          const parts = conn.color.split('-');
          const c1 = parts[0].toLowerCase();
          const c2 = parts[1].toLowerCase();
          const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
          
          // IT-themed gradient
          if (c1 === 'white' && c2 === 'green') {
            gradient.addColorStop(0, '#00e5ff');
            gradient.addColorStop(1, '#0056b3');
          } else if (c1 === 'white' && c2 === 'orange') {
            gradient.addColorStop(0, '#00e5ff');
            gradient.addColorStop(1, '#0078d4');
          } else if (c1 === 'white' && c2 === 'blue') {
            gradient.addColorStop(0, '#00e5ff');
            gradient.addColorStop(1, '#0056b3');
          } else if (c1 === 'white' && c2 === 'brown') {
            gradient.addColorStop(0, '#0078d4');
            gradient.addColorStop(1, '#0056b3');
          } else {
            gradient.addColorStop(0, c1);
            gradient.addColorStop(1, c2);
          }
          
          ctx.strokeStyle = gradient;
        } else {
          // IT-themed solid colors
          switch(conn.color.toLowerCase()) {
            case 'green':
              ctx.strokeStyle = '#00e5ff';
              break;
            case 'blue':
              ctx.strokeStyle = '#0056b3';
              break;
            case 'orange':
              ctx.strokeStyle = '#0078d4';
              break;
            case 'brown':
              ctx.strokeStyle = '#004080';
              break;
            default:
              ctx.strokeStyle = conn.color.toLowerCase();
          }
        }
        
        // Add glow effect to lines
        ctx.shadowColor = '#00e5ff';
        ctx.shadowBlur = 8; 
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Draw data flow animation (Purely Visual)
        if (connections.length > 0) {
          // Calculate position along the bezier curve
          const t = animationProgress;
          const t2 = t * t;
          const t3 = t2 * t;
          const mt = 1 - t;
          const mt2 = mt * mt;
          const mt3 = mt2 * mt;
          
          const flowX = mt3 * x1 + 3 * mt2 * t * cp1X + 3 * mt * t2 * cp2X + t3 * x2;
          const flowY = mt3 * y1 + 3 * mt2 * t * cp1Y + 3 * mt * t2 * cp2Y + t3 * y2;
          
          // Draw data packet
          ctx.beginPath();
          ctx.arc(flowX, flowY, 8, 0, Math.PI * 2); 
          ctx.fillStyle = '#39ff14';
          ctx.fill();
          
          // Add glow to data packet
          ctx.beginPath();
          ctx.arc(flowX, flowY, 12, 0, Math.PI * 2); 
          const gradient = ctx.createRadialGradient(flowX, flowY, 0, flowX, flowY, 12);
          gradient.addColorStop(0, 'rgba(57, 255, 20, 0.8)');
          gradient.addColorStop(1, 'rgba(57, 255, 20, 0)');
          ctx.fillStyle = gradient;
          ctx.fill();
        }
      });
    }
    
    // Start animation loop (Purely Visual)
    function startAnimation() {
      function animate() {
        animationProgress += 0.01;
        if (animationProgress > 1) animationProgress = 0;
        
        drawConnections();
        animationId = requestAnimationFrame(animate);
      }
      
      if (animationId) cancelAnimationFrame(animationId);
      animate();
    }
    
    // === Reward Logic (Original Backend Logic) ===
    async function giveReward() {
      const username = localStorage.getItem("loggedInUser");
      if (!username) {
        alert("‚ö†Ô∏è No username found in localStorage. Please login first.");
        return;
      }
      try {
        const response = await fetch("https://postgres-test-p05s.onrender.com/api/reward", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            username,                     // ‚úÖ required
            points: 100,
            coins: 100,
            reason: "Perfect Score T568B"
          })
        });
        const data = await response.json();
        if (data.success) {
          alert(`üéÅ Reward Granted: +100 Points, +100 Coins`);
        } else {
          console.error("Reward API failed:", data);
        }
      } catch (err) {
        console.error("Reward API Error:", err);
      }
    }
    
    function checkWiring() {
      const correctOrder = [
        'White-Orange', 'Orange', 'White-Green', 'Blue',
        'White-Blue', 'Green', 'White-Brown', 'Brown'
      ];
      if (connections.length < 8) {
        alert("‚ö†Ô∏è Incomplete: Please connect all wires.");
        return;
      }
      const currentOrder = [];
      for (let i = 1; i <= 8; i++) {
        const match = connections.find(c => c.pin === i.toString());
        currentOrder.push(match ? match.color : null);
      }
      let correct = 0;
      connections.forEach(c => c.wire.classList.remove("correct", "incorrect"));
      correctOrder.forEach((c, i) => {
        if (c === currentOrder[i]) {
          correct++;
          const wireObj = connections.find(conn => conn.color === c);
          if (wireObj) wireObj.wire.classList.add("correct");
        } else {
          const wireObj = connections.find(conn => conn.color === currentOrder[i]);
          if (wireObj) wireObj.wire.classList.add("incorrect");
        }
      });
      if (correct === 8) {
        resultEl.textContent = "üíª Perfect! All wires are correct.";
        resultEl.style.color = "#00e5ff";
        alert("üíª Perfect! All wires are correct.");
        // === Reward API call ===
        const username = localStorage.getItem("loggedInUser"); // or session variable
        if (username) {
          fetch("/api/reward", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              username,
              points: 3040, 
              coins: 1520,
              reason: "Perfect Score T568B"
            })
          })
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              alert("üèÜ You earned 3060 points and 1560 coins!");
              // ‚úÖ Redirect after reward
              window.location.href = "../levels/networkinglevels.html";
            } else {
              console.error("Reward API failed:", data);
              // still redirect to levels page even if reward API fails
              window.location.href = "../levels/networkinglevels.html";
            }
          })
          .catch(err => {
            console.error("Reward error:", err);
            // redirect even if error
            window.location.href = "../levels/networkinglevels.html";
          });
        } else {
          console.log("username is null");
          // still redirect if no username found
          window.location.href = "../levels/networkinglevels.html";
        }
      }
    }
    
    // Handle window resize for game canvas
    window.addEventListener('resize', () => {
      if (document.getElementById('gameSection').style.display === 'flex') {
        setGameCanvasSize();
        drawConnections();
      }
    });
    
    // === üéµ GAME MUSIC SYSTEM ===
    let audioCtx, masterGain, intervalIds = [];
    function startGameMusic() {
      if (audioCtx) return; // already playing
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.8; // üéö overall volume
      masterGain.connect(audioCtx.destination);
      // üîπ Driving Bassline
      intervalIds.push(setInterval(() => {
        playTone(55, "square", 0.3, 0.4); // Low note
        setTimeout(() => playTone(110, "square", 0.2, 0.3), 200); // Octave hit
      }, 800));
      // üîπ Melody Arpeggio (classic retro blips)
      intervalIds.push(setInterval(() => {
        let notes = [440, 494, 523, 587, 659, 698, 784]; // C major scale
        let note = notes[Math.floor(Math.random() * notes.length)];
        playTone(note, "square", 0.25, 0.25);
      }, 300));
      // üîπ Hi-Hat / Percussion
      intervalIds.push(setInterval(() => {
        playNoise(0.03, 0.2);
      }, 200));
      // üîπ Kick Drum (boom effect)
      intervalIds.push(setInterval(() => {
        playKick();
      }, 1200));
    }
    function stopGameMusic() {
      intervalIds.forEach(id => clearInterval(id));
      intervalIds = [];
      if (audioCtx) {
        audioCtx.close();
        audioCtx = null;
      }
    }
    // === SOUND GENERATORS ===
    function playTone(freq, type, duration, volume) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      gain.gain.value = volume;
      osc.type = type;
      osc.frequency.value = freq;
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }
    function playNoise(duration, volume) {
      const bufferSize = audioCtx.sampleRate * duration;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1; // white noise
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      const gain = audioCtx.createGain();
      gain.gain.value = volume;
      noise.connect(gain);
      gain.connect(masterGain);
      noise.start();
      noise.stop(audioCtx.currentTime + duration);
    }
    function playKick() {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(150, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
      gain.gain.setValueAtTime(0.6, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.5);
    }
  </script>
</body>
</html>